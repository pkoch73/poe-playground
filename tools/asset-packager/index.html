<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marketing Media Organizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script defer type="text/javascript" src="https://rum.hlx.page/.rum/@adobe/helix-rum-js@^2/dist/rum-standalone.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        secondary: '#4F4EBD'
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-800 dark:text-gray-200 min-h-screen">
    <!-- Dark mode detection -->
    <script>
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });
    </script>

    <div class="container mx-auto px-4 py-8 max-w-7xl">
        <div class="flex justify-between items-center mb-8">
            <h1 class="text-3xl font-bold text-primary">Marketing Media Organizer</h1>
            <div class="flex items-center space-x-4">
                <span id="mode-indicator" class="px-3 py-1 text-sm font-medium rounded-full bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200">
                    Demo Mode
                </span>
                <button id="signInBtn" class="bg-primary hover:bg-secondary text-white font-semibold py-2 px-4 rounded transition flex items-center">
                    <i class="fas fa-sign-in-alt mr-2"></i>Sign In with Adobe
                </button>
                <button id="config-btn" class="bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 font-semibold py-2 px-4 rounded transition" onclick="openSettingsModal()">
                    <i class="fas fa-cog mr-2"></i>Settings
                </button>
            </div>
        </div>
        
        <!-- Collection search screen - shown initially -->
        <div id="welcome-container" class="flex flex-col items-center justify-center my-12">
            <div class="text-center mb-10">
                <i class="fas fa-folder-open text-6xl text-primary mb-4"></i>
                <h2 class="text-2xl font-bold mb-2">Welcome to the Marketing Media Organizer</h2>
                <p class="text-lg text-gray-600 dark:text-gray-400 max-w-2xl">
                    Search for a collection below to get started. Once selected, you can apply filters to organize your marketing assets.
                </p>
            </div>
            
            <!-- Collections Search Panel -->
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md w-full max-w-3xl">
                <h2 class="text-xl font-semibold mb-4">Find a Collection</h2>
                
                <div class="space-y-4">
                    <div>
                        <label for="collection-search" class="sr-only">Search Collections</label>
                        <div class="relative">
                            <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                                <svg class="h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
                                </svg>
                            </div>
                            <input id="collection-search-welcome" class="block w-full pl-10 pr-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md leading-5 bg-gray-50 dark:bg-gray-700 text-base placeholder-gray-500 focus:outline-none focus:ring-primary focus:border-primary" type="search" placeholder="Search collections by name or description...">
                        </div>
                    </div>
                    
                    <div class="bg-gray-50 dark:bg-gray-700 rounded-md p-2 h-72 overflow-y-auto">
                        <ul id="collections-list-welcome" class="space-y-1">
                            <!-- Collections will be populated here -->
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Main workspace - initially hidden, shown after collection selection -->
        <div id="workspace-container" class="hidden">
            <!-- Breadcrumb navigation -->
            <div class="flex items-center mb-6 text-sm">
                <button id="back-to-collections-btn" class="text-primary hover:text-secondary flex items-center">
                    <i class="fas fa-arrow-left mr-2"></i>
                    Back to Collections
                </button>
                <span class="mx-2 text-gray-500 dark:text-gray-400">/</span>
                <span id="breadcrumb-collection" class="font-medium"></span>
            </div>
            
            <div class="grid grid-cols-1 lg:grid-cols-12 gap-6" style="height: 580px;">
                <!-- Left Panel: Search and Filters -->
                <div class="lg:col-span-3 space-y-6 flex flex-col">
                    <!-- Authentication Status Panel - Hidden when authenticated -->
                    <div id="auth-panel" class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow-md">
                        <h2 class="text-xl font-semibold mb-4">Authentication</h2>
                        
                        <div class="space-y-4">
                            <div id="authStatus" class="text-sm">
                                <span class="text-red-500 dark:text-red-400 flex items-center">
                                    <i class="fas fa-circle text-xs mr-2"></i>Not signed in
                                </span>
                            </div>
                            
                            <div class="text-xs text-gray-500 dark:text-gray-400">
                                Sign in with your Adobe ID to access assets from Adobe Experience Manager.
                            </div>
                            
                            <!-- Hidden IMS token field -->
                            <div class="hidden">
                                <input type="text" id="imsToken" class="w-full">
                            </div>
                            
                            <!-- For demo/testing, add API endpoint fields -->
                            <div class="hidden">
                                <input type="text" id="apiEndpoint" value="https://experience.adobe.com/api/assets" class="w-full">
                                <input type="text" id="apiKey" value="demo-key-1234" class="w-full">
                                <input type="text" id="limitResults" value="100" class="w-full">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Active Collection Panel -->
                    <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow-md">
                        <h2 class="text-xl font-semibold mb-4">Active Collection</h2>
                        
                        <div id="active-collection-details" class="space-y-4">
                            <div class="p-3 bg-gray-50 dark:bg-gray-700 rounded-md">
                                <div class="font-medium mb-1" id="collection-title"></div>
                                <div class="text-sm text-gray-500 dark:text-gray-400" id="collection-description"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Filters Panel -->
                    <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow-md flex-1 flex flex-col">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-xl font-semibold">Apply Filters</h2>
                        </div>
                        
                        <div class="space-y-4 flex-1 overflow-y-auto">
                            <div>
                                <label for="channel" class="block text-sm font-medium mb-1">Channel</label>
                                <select id="channel" class="w-full bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md px-3 py-2 text-base">
                                    <option value="">All Channels</option>
                                </select>
                            </div>
                            
                            <div>
                                <label for="country" class="block text-sm font-medium mb-1">Country</label>
                                <select id="country" class="w-full bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md px-3 py-2 text-base">
                                    <option value="">All Countries</option>
                                </select>
                            </div>
                            
                            <div>
                                <label for="language" class="block text-sm font-medium mb-1">Language</label>
                                <select id="language" class="w-full bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md px-3 py-2 text-base">
                                    <option value="">All Languages</option>
                                </select>
                            </div>

                            <div>
                                <label for="variation" class="block text-sm font-medium mb-1">Variation</label>
                                <select id="variation" class="w-full bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md px-3 py-2 text-base">
                                    <option value="">All Variations</option>
                                </select>
                            </div>
                        </div>

                        <div class="mt-4 space-y-3">
                            <button id="apply-filters" class="w-full bg-primary hover:bg-secondary text-white font-semibold py-2 px-4 rounded transition">
                                Apply Filters
                            </button>
                            
                            <button id="clear-filters" class="w-full bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 font-semibold py-2 px-4 rounded transition">
                                Reset Filters
                            </button>
                            
                            <button id="recover-assets-btn" class="w-full bg-orange-500 hover:bg-orange-600 text-white font-semibold py-2 px-4 rounded transition">
                                Recover Assets View
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Assets Panel -->
                <div class="lg:col-span-5 bg-white dark:bg-gray-800 p-4 rounded-lg shadow-md flex flex-col h-full">
                    <h2 class="text-xl font-semibold mb-4">Matching Assets</h2>
                    <div id="assets-count" class="text-sm text-gray-500 dark:text-gray-400 mb-4">
                        Showing 0 assets
                    </div>
                    
                    <div id="assets-container" class="grid grid-cols-1 sm:grid-cols-2 gap-4 overflow-y-auto p-1 flex-grow h-0 min-h-0">
                        <!-- Assets will be populated here -->
                    </div>
                </div>
                
                <!-- Folder Structure Panel -->
                <div class="lg:col-span-4 bg-white dark:bg-gray-800 p-4 rounded-lg shadow-md flex flex-col h-full">
                    <h2 class="text-xl font-semibold mb-4">Folder Structure Preview</h2>
                    
                    <div id="folder-structure" class="text-sm bg-gray-50 dark:bg-gray-700 p-4 rounded-md overflow-y-auto font-mono flex-grow h-0 min-h-0">
                        <!-- Folder structure will be populated here -->
                    </div>
                    
                    <div class="mt-4">
                        <button id="export-btn" class="bg-primary hover:bg-secondary text-white font-semibold py-2 px-4 rounded transition w-full">
                            Export to Cloudflare
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Notification Toast -->
    <div id="notification" class="fixed bottom-5 right-5 max-w-sm bg-white dark:bg-gray-800 shadow-lg rounded-lg pointer-events-auto ring-1 ring-black ring-opacity-5 overflow-hidden transform transition-all duration-300 scale-0 opacity-0">
        <div class="p-4">
            <div class="flex items-start">
                <div id="notification-icon" class="flex-shrink-0 mr-3">
                    <!-- Icon will be inserted by JS -->
                </div>
                <div class="flex-1 pt-0.5">
                    <p id="notification-message" class="text-sm font-medium text-gray-900 dark:text-gray-100">
                        <!-- Message content will be inserted by JS -->
                    </p>
                </div>
                <div class="ml-4 flex-shrink-0 flex">
                    <button id="close-notification" class="bg-white dark:bg-gray-800 rounded-md inline-flex text-gray-400 hover:text-gray-500">
                        <span class="sr-only">Close</span>
                        <svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Share Modal Removed -->

    <!-- Settings Modal -->
    <div id="config-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-xl w-full">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold">Settings</h3>
                <button id="close-config-modal" class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200" onclick="closeSettingsModal()">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>

            <div class="space-y-6">
                <!-- Tabs -->
                <div class="border-b border-gray-200 dark:border-gray-700">
                    <nav class="-mb-px flex space-x-8">
                        <button id="tab-btn-cloudflare" class="tab-btn border-primary text-primary border-b-2 whitespace-nowrap py-2 px-1 font-medium">
                            Cloudflare
                        </button>
                        <button id="tab-btn-adobe" class="tab-btn border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 whitespace-nowrap py-2 px-1 font-medium">
                            Adobe Experience Manager
                        </button>
                    </nav>
                </div>
                
                <!-- Tab content -->
                <div id="tab-content-cloudflare" class="tab-content space-y-4">
                    <div>
                        <label for="api-url" class="block text-sm font-medium mb-1">API URL</label>
                        <input type="text" id="api-url" class="w-full bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md px-3 py-2 text-base" placeholder="https://your-worker.workers.dev">
                    </div>
                    
                    <div>
                        <label for="api-key" class="block text-sm font-medium mb-1">API Key</label>
                        <input type="password" id="api-key" class="w-full bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md px-3 py-2 text-base" placeholder="Your API key">
                    </div>
                    
                    <div>
                        <label for="base-folder" class="block text-sm font-medium mb-1">Base Folder Path</label>
                        <input type="text" id="base-folder" class="w-full bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md px-3 py-2 text-base" placeholder="gmo-assets/">
                        <p class="mt-1 text-xs text-gray-500 dark:text-gray-400">Note: Folder paths should end with a forward slash (/).</p>
                    </div>
                    
                    <div class="flex items-center space-x-2 mt-4">
                        <input type="checkbox" id="remember-config" class="w-4 h-4 text-primary border-gray-300 rounded focus:ring-primary">
                        <label for="remember-config" class="text-sm font-medium">Remember configuration (stored locally)</label>
                    </div>
                    
                    <div class="flex justify-between pt-4">
                        <button id="test-connection-btn" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded transition">
                            Test Connection
                        </button>
                        <div>
                            <button id="clear-config-btn" class="mr-2 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 font-semibold py-2 px-4 rounded transition">
                                Clear
                            </button>
                            <button id="save-config-btn" class="bg-primary hover:bg-secondary text-white font-semibold py-2 px-4 rounded transition">
                                Save
                            </button>
                        </div>
                    </div>
                </div>
                
                <div id="tab-content-adobe" class="tab-content space-y-4 hidden">
                    <div class="bg-blue-50 dark:bg-blue-900/20 border-l-4 border-blue-500 p-4 mb-4">
                        <h4 class="font-bold mb-2">Adobe Authentication Status</h4>
                        <p class="mb-2" id="adobe-auth-status">Not authenticated. Use the "Sign in with Adobe" button to connect.</p>
                        
                        <div id="adobe-user-info" class="hidden">
                            <div class="text-sm space-y-1 mt-3">
                                <p><strong>User:</strong> <span id="adobe-username">-</span></p>
                                <p><strong>Organization:</strong> <span id="adobe-org">-</span></p>
                                <p><strong>Token Expires:</strong> <span id="adobe-token-expires">-</span></p>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <label for="aem-endpoint" class="block text-sm font-medium mb-1">AEM Assets Endpoint</label>
                        <input type="text" id="aem-endpoint" class="w-full bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md px-3 py-2 text-base" placeholder="https://author-pXXXXX-eXXXXX.adobeaemcloud.com">
                    </div>
                    
                    <div>
                        <label for="aem-path" class="block text-sm font-medium mb-1">Base Path</label>
                        <input type="text" id="aem-path" class="w-full bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md px-3 py-2 text-base" value="/content/dam/assets" placeholder="/content/dam/assets">
                    </div>
                    
                    <div class="mt-4 border-t dark:border-gray-700 pt-4">
                        <h4 class="font-bold mb-2">API Connection Options</h4>
                        
                        <div class="flex items-center justify-between">
                            <label for="use-cors-proxy" class="font-medium">Use CORS Proxy</label>
                            <div class="relative inline-block w-12 h-6 transition duration-200 ease-in-out">
                                <input type="checkbox" id="use-cors-proxy" class="absolute w-6 h-6 opacity-0 z-10 cursor-pointer peer" checked>
                                <span class="absolute left-0 top-0 right-0 bottom-0 bg-gray-300 dark:bg-gray-600 peer-checked:bg-primary rounded-full transition-all duration-200 before:absolute before:content-[''] before:top-[2px] before:left-[2px] before:bg-white before:border-gray-300 before:border before:rounded-full before:h-5 before:w-5 before:transition-all before:duration-200 peer-checked:before:translate-x-6"></span>
                            </div>
                        </div>
                        <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">Enable this to use the CORS proxy for API requests. Disable for direct API calls (may cause CORS errors).</p>
                    </div>

                    <div class="flex justify-end pt-4">
                        <button id="save-adobe-config-btn" class="bg-primary hover:bg-secondary text-white font-semibold py-2 px-4 rounded transition">
                            Save
                        </button>
                    </div>
                </div>
            </div>
            
            <div id="connection-status" class="mt-4 hidden">
                <div class="p-3 rounded-md"></div>
            </div>
        </div>
    </div>

    <!-- Export Postfix Modal -->
    <div id="export-postfix-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full">
            <h3 class="text-xl font-bold mb-4">Collection Postfix</h3>
            <p class="mb-4">Add a postfix to the collection name for this export. This will help identify different versions of the same collection.</p>
            
            <div class="mb-4">
                <label for="collection-postfix" class="block text-sm font-medium mb-1">Postfix</label>
                <div class="flex items-center gap-2">
                    <div id="collection-prefix" class="text-gray-500 dark:text-gray-400 font-medium flex-none truncate max-w-[50%]">Collection_</div>
                    <input type="text" id="collection-postfix" class="flex-1 bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md px-3 py-2 text-base" placeholder="v1">
                </div>
                <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">Final name will be: <span id="final-name-preview">Collection_v1</span></p>
                <p id="postfix-error" class="text-xs text-red-500 dark:text-red-400 mt-1 hidden">Please enter a valid postfix (letters, numbers, underscores only)</p>
            </div>
            
            <div class="flex justify-end space-x-3">
                <button id="cancel-postfix-btn" class="bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 font-semibold py-2 px-4 rounded transition">
                    Cancel
                </button>
                <button id="apply-postfix-btn" class="bg-primary hover:bg-secondary text-white font-semibold py-2 px-4 rounded transition">
                    Continue Export
                </button>
            </div>
        </div>
    </div>

    <!-- Export Progress Modal -->
    <div id="export-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full">
            <h3 class="text-xl font-bold mb-4">Exporting to Cloudflare</h3>
            <div class="mb-4">
                <div class="flex items-center justify-between mb-2">
                    <span>Progress:</span>
                    <span id="export-percentage">0%</span>
                </div>
                <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5">
                    <div id="export-progress-bar" class="bg-primary h-2.5 rounded-full" style="width: 0%"></div>
                </div>
            </div>
            <div id="export-status" class="text-sm mb-4 h-16 overflow-y-auto">
                Preparing to export assets...
            </div>
            <div class="flex justify-end">
                <button id="cancel-export-btn" class="bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 font-semibold py-2 px-4 rounded transition">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Success Modal -->
    <div id="success-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-xl w-full">
            <h3 class="text-xl font-bold mb-4">Success!</h3>
            <p class="mb-4" id="success-message">The assets have been organized and exported to Cloudflare.</p>
            
            <!-- Read-only View Link Section -->
            <div id="readonly-link-section" class="mb-6 mt-3 bg-blue-50 dark:bg-blue-900/20 border-l-4 border-blue-500 p-4 rounded-r-md">
                <h4 class="font-semibold mb-2 flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-blue-500" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                    </svg>
                    Read-only View Link
                </h4>
                <p class="text-sm mb-3">Share this link with users who need to view or download the assets:</p>
                <div class="flex">
                    <input type="text" id="readonly-view-link" readonly class="flex-1 py-2 px-3 text-sm border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 rounded-l-md focus:outline-none focus:ring-1 focus:ring-primary" value="">
                    <button id="copy-readonly-link" class="bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-3 rounded-r-md flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z" />
                            <path d="M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z" />
                        </svg>
                        Copy
                    </button>
                </div>
                <div class="mt-3 text-xs text-gray-500 dark:text-gray-400">
                    This link gives view-only access to the exported content structure with download capabilities.
                </div>
            </div>
            
            <div class="flex justify-between space-x-3">
                <button id="view-readonly-btn" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded transition">
                    <span class="flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
                            <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd" />
                        </svg>
                        View Content
                    </span>
                </button>
                <button id="close-success-modal" class="bg-primary hover:bg-secondary text-white font-semibold py-2 px-4 rounded transition">
                    Close
                </button>
            </div>
        </div>
    </div>

    <!-- Error Modal -->
    <div id="error-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full">
            <h3 class="text-xl font-bold mb-4 text-red-600 dark:text-red-400">Error</h3>
            <p class="mb-6" id="error-message">An error occurred during the operation.</p>
            <div class="flex justify-end">
                <button id="close-error-modal" class="bg-primary hover:bg-secondary text-white font-semibold py-2 px-4 rounded transition">
                    Close
                </button>
            </div>
        </div>
    </div>

    <script>
        // Simulated content hub data
        const contentHubAssets = [
            { id: 1, name: "Brand Guidelines.pdf", type: "document", project: "Rebrand 2023", channel: "Digital", country: "gl", language: "en", countryLanguage: "gl-en", variation: "Standard" },
            { id: 2, name: "Q1 Campaign Assets.zip", type: "archive", project: "Q1 Campaign", channel: "Social Media", country: "us", language: "en", countryLanguage: "us-en", variation: "Standard" },
            { id: 3, name: "Product Photo 1.jpg", type: "image", project: "Product Launch", channel: "E-commerce", country: "de", language: "de", countryLanguage: "de-de", variation: "Product A" },
            { id: 4, name: "Product Photo 2.jpg", type: "image", project: "Product Launch", channel: "E-commerce", country: "de", language: "de", countryLanguage: "de-de", variation: "Product B" },
            { id: 5, name: "Product Video.mp4", type: "video", project: "Product Launch", channel: "E-commerce", country: "fr", language: "fr", countryLanguage: "fr-fr", variation: "Standard" },
            { id: 6, name: "TV Commercial.mp4", type: "video", project: "Q1 Campaign", channel: "TV", country: "gb", language: "en", countryLanguage: "gb-en", variation: "30s" },
            { id: 7, name: "Podcast Ad.mp3", type: "audio", project: "Q1 Campaign", channel: "Audio", country: "us", language: "en", countryLanguage: "us-en", variation: "60s" },
            { id: 8, name: "Logo Dark.png", type: "image", project: "Rebrand 2023", channel: "Digital", country: "gl", language: "en", countryLanguage: "gl-en", variation: "Dark" },
            { id: 9, name: "Logo Light.png", type: "image", project: "Rebrand 2023", channel: "Digital", country: "gl", language: "en", countryLanguage: "gl-en", variation: "Light" },
            { id: 10, name: "Social Post Template.psd", type: "design", project: "Q1 Campaign", channel: "Social Media", country: "jp", language: "ja", countryLanguage: "jp-ja", variation: "Instagram" },
            { id: 11, name: "Email Template.html", type: "code", project: "Q1 Campaign", channel: "Email", country: "br", language: "pt", countryLanguage: "br-pt", variation: "Newsletter" },
            { id: 12, name: "Product Brochure FR.pdf", type: "document", project: "Product Launch", channel: "Print", country: "fr", language: "fr", countryLanguage: "fr-fr", variation: "Brochure" },
            { id: 13, name: "Product Brochure DE.pdf", type: "document", project: "Product Launch", channel: "Print", country: "de", language: "de", countryLanguage: "de-de", variation: "Brochure" },
            { id: 14, name: "Digital Banner 300x250.jpg", type: "image", project: "Q1 Campaign", channel: "Display", country: "es", language: "es", countryLanguage: "es-es", variation: "Small" },
            { id: 15, name: "Digital Banner 728x90.jpg", type: "image", project: "Q1 Campaign", channel: "Display", country: "es", language: "es", countryLanguage: "es-es", variation: "Large" },
            { id: 16, name: "Digital Banner 300x250.jpg", type: "image", project: "Q1 Campaign", channel: "Display", country: "mx", language: "es", countryLanguage: "mx-es", variation: "Small" },
            { id: 17, name: "Digital Banner 728x90.jpg", type: "image", project: "Q1 Campaign", channel: "Display", country: "mx", language: "es", countryLanguage: "mx-es", variation: "Large" },
            { id: 18, name: "Website Copy.docx", type: "document", project: "Product Launch", channel: "Website", country: "ca", language: "en", countryLanguage: "ca-en", variation: "Homepage" },
            { id: 19, name: "Website Copy FR.docx", type: "document", project: "Product Launch", channel: "Website", country: "ca", language: "fr", countryLanguage: "ca-fr", variation: "Homepage" },
            { id: 20, name: "PR Release.docx", type: "document", project: "Product Launch", channel: "PR", country: "us", language: "en", countryLanguage: "us-en", variation: "Press Kit" },
        ];

        // Sample collections data
        const sampleCollections = [
            {
                id: 1,
                name: "Global Brand Assets",
                description: "All global brand assets from the rebrand",
                filters: {
                    project: "Rebrand 2023",
                    channel: "Digital",
                    country: "gl",
                    language: "en",
                    variation: ""
                }
            },
            {
                id: 2,
                name: "Q1 Campaign - US",
                description: "All Q1 Campaign assets for the US market",
                filters: {
                    project: "Q1 Campaign",
                    channel: "",
                    country: "us",
                    language: "en",
                    variation: ""
                }
            },
            {
                id: 3,
                name: "Product Launch - Germany",
                description: "Product launch assets for the German market",
                filters: {
                    project: "Product Launch",
                    channel: "",
                    country: "de",
                    language: "de",
                    variation: ""
                }
            },
            {
                id: 4,
                name: "Digital Banners - All Markets",
                description: "Digital banner ads for all markets",
                filters: {
                    project: "Q1 Campaign",
                    channel: "Display",
                    country: "",
                    language: "",
                    variation: ""
                }
            }
        ];

        // Define file type icons
        const fileTypeIcons = {
            document: "üìÑ",
            archive: "üóÑÔ∏è",
            image: "üñºÔ∏è",
            video: "üé¨",
            audio: "üîä",
            design: "üé®",
            code: "üíª"
        };

        // Current folder structure for sharing
        let currentFolderStructure = null;

        // Adobe IMS Configuration
        const imsConfig = {
            clientId: 'aemcs-poe-assetselector', // AEM CS Assets Selector client ID
            redirectUri: window.location.href, // Use current URL as redirect
            scope: 'AdobeID,openid,read_organizations,additional_info.projectedProductContext',
            responseType: 'token' // Using implicit grant flow for client-side apps
        };

        // Function to display notifications
        function showNotification(message, type = 'info', duration = 5000) {
            const notification = document.getElementById('notification');
            const messageElement = document.getElementById('notification-message');
            const iconElement = document.getElementById('notification-icon');
            
            // Set message
            messageElement.textContent = message;
            
            // Set icon based on type
            let iconHtml = '';
            let notificationClasses = '';
            
            switch(type) {
                case 'success':
                    iconHtml = '<svg class="h-6 w-6 text-green-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>';
                    notificationClasses = 'bg-green-50 dark:bg-green-900/20 text-green-800 dark:text-green-200';
                    break;
                case 'error':
                    iconHtml = '<svg class="h-6 w-6 text-red-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>';
                    notificationClasses = 'bg-red-50 dark:bg-red-900/20 text-red-800 dark:text-red-200';
                    break;
                case 'warning':
                    iconHtml = '<svg class="h-6 w-6 text-yellow-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>';
                    notificationClasses = 'bg-yellow-50 dark:bg-yellow-900/20 text-yellow-800 dark:text-yellow-200';
                    break;
                default: // info
                    iconHtml = '<svg class="h-6 w-6 text-blue-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>';
                    notificationClasses = 'bg-blue-50 dark:bg-blue-900/20 text-blue-800 dark:text-blue-200';
            }
            
            iconElement.innerHTML = iconHtml;
            notification.className = notification.className.replace(/bg-\w+-\d+ dark:bg-\w+-\d+\/\d+ text-\w+-\d+ dark:text-\w+-\d+/g, '');
            notification.classList.add(...notificationClasses.split(' '));
            
            // Show notification
            notification.classList.remove('scale-0', 'opacity-0');
            notification.classList.add('scale-100', 'opacity-100');
            
            // Close after duration
            const timeoutId = setTimeout(() => {
                notification.classList.remove('scale-100', 'opacity-100');
                notification.classList.add('scale-0', 'opacity-0');
            }, duration);
            
            // Set up close button
            const closeBtn = document.getElementById('close-notification');
            const closeFn = () => {
                clearTimeout(timeoutId);
                notification.classList.remove('scale-100', 'opacity-100');
                notification.classList.add('scale-0', 'opacity-0');
                closeBtn.removeEventListener('click', closeFn);
            };
            
            closeBtn.addEventListener('click', closeFn);
        }

        /**
         * CloudflareService - Interface for interacting with the Cloudflare Worker API
         */
        class CloudflareService {
            constructor(config) {
                this.config = config;
                this.baseUrl = config.url;
                this.apiKey = config.apiKey;
                this.baseFolder = config.folder;
                
                // Ensure base folder ends with a slash
                if (this.baseFolder && !this.baseFolder.endsWith('/')) {
                    this.baseFolder += '/';
                }
            }
            
            /**
             * Get the appropriate file extension for a given asset type
             * @param {string} assetType - Type of the asset (e.g., "image", "document")
             * @param {string} formatHint - Optional format hint from metadata
             * @returns {string} Appropriate file extension without the dot
             */
            getFileExtensionForType(assetType, formatHint) {
                // If we have a format hint that's already an extension, use it
                if (formatHint && typeof formatHint === 'string' && !formatHint.includes('/')) {
                    return formatHint.toLowerCase();
                }
                
                // Otherwise determine by asset type
                switch(assetType) {
                    case 'image':
                        return 'jpg';
                    case 'video':
                        return 'mp4';
                    case 'audio':
                        return 'mp3';
                    case 'document':
                        return 'pdf';
                    case 'archive':
                        return 'zip';
                    case 'code':
                        return 'html';
                    case 'design':
                        return 'psd';
                    default:
                        return 'txt';
                }
            }
            
            /**
             * Get headers for API requests
             * @returns {Object} Headers with API key
             */
            getHeaders() {
                return {
                    'x-api-key': this.apiKey,
                    'Content-Type': 'application/json'
                };
            }
            
            /**
             * Test connection to the Cloudflare Worker
             * @returns {Promise<Object>} Result of the connection test
             */
            async testConnection() {
                try {
                    // Try to list files in the base folder to test connection
                    const response = await fetch(`${this.baseUrl}?key=${this.baseFolder || ''}`, {
                        method: 'LIST',
                        headers: this.getHeaders()
                    });
                    
                    if (!response.ok) {
                        const text = await response.text();
                        throw new Error(`API error: ${text}`);
                    }
                    
                    return { 
                        success: true, 
                        message: "Connection successful! API is accessible." 
                    };
                } catch (error) {
                    console.error('Cloudflare connection test failed:', error);
                    return { 
                        success: false, 
                        message: error.message 
                    };
                }
            }
            
            /**
             * Create a folder in the Cloudflare R2 storage
             * @param {string} path Folder path to create
             * @returns {Promise<Object>} Result of the folder creation
             */
            async createFolder(path) {
                try {
                    // Ensure path ends with a slash
                    if (!path.endsWith('/')) {
                        path += '/';
                    }
                    
                    const response = await fetch(`${this.baseUrl}?key=${encodeURIComponent(path)}`, {
                        method: 'POST',
                        headers: this.getHeaders()
                    });
                    
                    if (!response.ok) {
                        const text = await response.text();
                        throw new Error(`Failed to create folder: ${text}`);
                    }
                    
                    return { success: true, path };
                } catch (error) {
                    console.error(`Error creating folder '${path}':`, error);
                    throw new Error(`Failed to create folder '${path}': ${error.message}`);
                }
            }
            
            /**
             * Upload a file to Cloudflare R2 storage
             * @param {string} path Path where the file should be stored
             * @param {string} fileName Name of the file
             * @param {ArrayBuffer|Blob} content Content of the file
             * @returns {Promise<Object>} Result of the file upload
             */
            async uploadFile(path, fileName, content) {
                try {
                    const fullPath = `${path}${fileName}`;
                    
                    const response = await fetch(`${this.baseUrl}?key=${encodeURIComponent(fullPath)}`, {
                        method: 'PUT',
                        headers: {
                            'x-api-key': this.apiKey
                            // Content-Type is determined by the Worker
                        },
                        body: content
                    });
                    
                    if (!response.ok) {
                        const text = await response.text();
                        throw new Error(`Failed to upload file: ${text}`);
                    }
                    
                    return { success: true, path: fullPath };
                } catch (error) {
                    console.error(`Error uploading file '${fileName}':`, error);
                    throw new Error(`Failed to upload file '${fileName}': ${error.message}`);
                }
            }
            
            /**
             * Download asset binary from Adobe Experience Manager
             * @param {Object} asset The asset object containing id and name
             * @returns {Promise<ArrayBuffer>} The binary content of the asset
             */
            async downloadAssetBinary(asset) {
                try {
                    if (!asset.id || typeof asset.id !== 'string' || !asset.id.includes('urn:aaid:aem:')) {
                        throw new Error("Asset does not have a valid Adobe AEM ID");
                    }
                    
                    // Format: https://delivery-p108396-e1040009.adobeaemcloud.com/adobe/assets/[assetId]/renditions/original/as/[filename]?attachment=true
                    const downloadUrl = `https://delivery-p108396-e1040009.adobeaemcloud.com/adobe/assets/${asset.id}/renditions/original/as/${encodeURIComponent(asset.name)}?attachment=true`;
                    
                    // Get the authentication token
                    const imsToken = document.getElementById('imsToken').value;
                    
                    // Check if we have authentication
                    if (!imsToken) {
                        throw new Error("Authentication required. Please sign in with Adobe first.");
                    }
                    
                    // Ensure token is properly formatted with Bearer prefix
                    const formattedToken = imsToken.startsWith('Bearer ') ? imsToken : `Bearer ${imsToken}`;
                    
                    // Log the download attempt
                    console.log(`Downloading asset binary from: ${downloadUrl}`);
                    
                    // Fetch the asset binary
                    const response = await fetch(downloadUrl, {
                        method: 'GET',
                        headers: {
                            'Authorization': formattedToken
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Failed to download asset: ${response.status} ${response.statusText}`);
                    }
                    
                    // Get the binary content as ArrayBuffer
                    const binaryContent = await response.arrayBuffer();
                    return binaryContent;
                } catch (error) {
                    console.error(`Error downloading asset '${asset.name}':`, error);
                    throw error;
                }
            }
            
            /**
             * Export assets to Cloudflare R2 with the folder structure
             * @param {Array} assets Array of assets to export
             * @param {Function} progressCallback Callback for progress updates
             * @returns {Promise<Object>} Export result
             */
            async exportAssets(assets, progressCallback) {
                // Log export initialization
                console.log(`CloudflareService.exportAssets: Starting export of ${assets.length} assets to Cloudflare R2`);
                
                if (!this.config) {
                    console.error("CloudflareService.exportAssets: Error - Cloudflare configuration not set");
                    throw new Error("Cloudflare configuration not set");
                }
                
                // Log configuration details
                console.log(`CloudflareService.exportAssets: Using configuration:
                - API URL: ${this.baseUrl}
                - Base Folder: ${this.baseFolder || '(root)'}`);
                
                // Get active collection name for folder naming
                const activeCollection = CollectionManager.activeCollection;
                const collectionName = activeCollection ? activeCollection.name : "Collection";
                
                // Group assets by collection name (as project), channel, countryLanguage, and variation
                console.log("CloudflareService.exportAssets: Organizing assets into folder structure...");
                const structure = {};
                
                // Create a single project entry using the collection name
                structure[collectionName] = {};
                
                assets.forEach(asset => {
                    const { channel, countryLanguage, variation } = asset;
                    
                    if (!structure[collectionName][channel]) structure[collectionName][channel] = {};
                    if (!structure[collectionName][channel][countryLanguage]) structure[collectionName][channel][countryLanguage] = {};
                    if (!structure[collectionName][channel][countryLanguage][variation]) structure[collectionName][channel][countryLanguage][variation] = [];
                    
                    structure[collectionName][channel][countryLanguage][variation].push(asset);
                });
                
                // Log the organization structure
                console.log("CloudflareService.exportAssets: Assets organized into structure:");
                console.log(`- Collection: ${collectionName}`);
                Object.entries(structure[collectionName]).forEach(([channel, countryLanguages]) => {
                    const totalAssets = Object.values(countryLanguages)
                        .flatMap(cl => Object.values(cl))
                        .flatMap(v => v)
                        .length;
                    console.log(`  - ${channel}: ${totalAssets} assets`);
                });
                
                // Store the structure for sharing
                currentFolderStructure = structure;
                
                // Calculate total operations for progress tracking
                // Each asset requires download and upload operations, plus folder creation
                const folderCount = this.countFolders(structure);
                const totalOperations = (assets.length * 2) + folderCount + 1; // +1 for base folder
                
                console.log(`CloudflareService.exportAssets: Export operations breakdown:
                - Total folders to create: ${folderCount + 1} (including base folder)
                - Total assets to process: ${assets.length} (each requires download + upload)
                - Total operations: ${totalOperations}`);
                
                let completedOperations = 0;
                
                try {
                    console.log(`CloudflareService.exportAssets: Beginning creation of folder structure`);
                    
                    // Create the base folder if specified
                    const basePath = this.baseFolder || '';
                    
                    if (basePath) {
                        console.log(`CloudflareService.exportAssets: Creating base folder: "${basePath}"`);
                        progressCallback(0, 'Creating base folder structure...');
                        await this.createFolder(basePath);
                        completedOperations++;
                        progressCallback(completedOperations / totalOperations * 100, `Created base folder: ${basePath}`);
                    }
                    
                    // Helper function to join path segments without double slashes
                    const joinPath = (basePath, segment) => {
                        if (!basePath) return segment + '/';
                        if (basePath.endsWith('/')) {
                            return basePath + segment + '/';
                        } else {
                            return basePath + '/' + segment + '/';
                        }
                    };
                    
                    // Process each level of the structure with collection as the project folder
                    for (const [project, channels] of Object.entries(structure)) {
                        // Create collection (project) folder
                        const projectPath = joinPath(basePath, project);
                        await this.createFolder(projectPath);
                        completedOperations++;
                        progressCallback(completedOperations / totalOperations * 100, `Created collection folder: ${project}`);
                        
                        for (const [channel, countryLanguages] of Object.entries(channels)) {
                            // Create channel folder
                            const channelPath = joinPath(projectPath, channel);
                            await this.createFolder(channelPath);
                            completedOperations++;
                            progressCallback(completedOperations / totalOperations * 100, `Created channel folder: ${channel}`);
                            
                            for (const [countryLanguage, variations] of Object.entries(countryLanguages)) {
                                // Create country-language folder
                                const countryLangPath = joinPath(channelPath, countryLanguage);
                                await this.createFolder(countryLangPath);
                                completedOperations++;
                                progressCallback(completedOperations / totalOperations * 100, `Created country-language folder: ${countryLanguage}`);
                                
                                for (const [variation, assetList] of Object.entries(variations)) {
                                    // Create variation folder
                                    const variationPath = joinPath(countryLangPath, variation);
                                    await this.createFolder(variationPath);
                                    completedOperations++;
                                    progressCallback(completedOperations / totalOperations * 100, `Created variation folder: ${variation}`);
                                    
                                    // Process each asset
                                    for (const asset of assetList) {
                                        try {
                                            // Check if this is a demo mode or if we have a real asset with ID
                                            let fileContent;
                                            let fileName = asset.name;
                                            
                                            // Ensure the file has an extension based on its type
                                            if (!fileName.includes('.')) {
                                                // Add appropriate extension based on asset type
                                                const extension = this.getFileExtensionForType(asset.type, asset.format);
                                                fileName = `${fileName}.${extension}`;
                                                console.log(`Added extension to file: ${fileName}`);
                                            }
                                            
                                            if (asset.id && typeof asset.id === 'string' && asset.id.includes('urn:aaid:aem:')) {
                                                // Download the real asset binary from AEM
                                                progressCallback(completedOperations / totalOperations * 100, `Downloading: ${fileName}`);
                                                
                                                try {
                                                    fileContent = await this.downloadAssetBinary(asset);
                                                    completedOperations++; // Count download as an operation
                                                    progressCallback(completedOperations / totalOperations * 100, `Downloaded: ${fileName}`);
                                                } catch (downloadError) {
                                                    console.error(`Download failed for ${fileName}:`, downloadError);
                                                    progressCallback(completedOperations / totalOperations * 100, `Download failed for ${fileName}: ${downloadError.message}`);
                                                    
                                                    // Create a placeholder binary for failed downloads
                                                    const errorMessage = `Failed to download ${fileName}: ${downloadError.message}`;
                                                    fileContent = new TextEncoder().encode(errorMessage).buffer;
                                                    
                                                    // For text error placeholders, ensure they have a .txt extension
                                                    if (!fileName.endsWith('.txt')) {
                                                        const nameWithoutExt = fileName.substring(0, fileName.lastIndexOf('.')) || fileName;
                                                        fileName = `${nameWithoutExt}.txt`;
                                                    }
                                                    
                                                    completedOperations++; // Still count the operation even though it failed
                                                }
                                            } else {
                                                // For demo assets without real IDs, create a placeholder appropriate for the file type
                                                const extension = fileName.split('.').pop().toLowerCase();
                                                
                                                // Create appropriate placeholder content based on file type
                                                if (extension === 'txt' || extension === 'html' || extension === 'css' || extension === 'js') {
                                                    // Text files get a simple demo text
                                                    const demoText = `This is a placeholder for ${fileName}.\nGenerated by Asset Organization Tool as a demo.\nFile type: ${asset.type || 'unknown'}\nFormat: ${asset.format || extension}`;
                                                    fileContent = new TextEncoder().encode(demoText).buffer;
                                                } else if (extension === 'json') {
                                                    // JSON files get valid JSON
                                                    const demoJson = JSON.stringify({
                                                        fileName: fileName,
                                                        description: "Demo placeholder file",
                                                        type: asset.type || "unknown",
                                                        format: asset.format || extension,
                                                        createdAt: new Date().toISOString()
                                                    }, null, 2);
                                                    fileContent = new TextEncoder().encode(demoJson).buffer;
                                                } else {
                                                    // Binary files get a minimal binary placeholder
                                                    // This creates a minimal valid file for common formats
                                                    if (extension === 'png') {
                                                        // Minimal valid PNG header (8 bytes)
                                                        fileContent = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82]).buffer;
                                                    } else if (extension === 'jpg' || extension === 'jpeg') {
                                                        // Minimal JPEG header
                                                        fileContent = new Uint8Array([255, 216, 255, 224, 0, 16, 74, 70, 73, 70, 0]).buffer;
                                                    } else if (extension === 'pdf') {
                                                        // Minimal PDF header
                                                        const pdfHeader = "%PDF-1.4\n%¬ø¬Ω¬ø¬Ω¬ø¬Ω¬ø¬Ω\n1 0 obj\n<</Type/Catalog/Pages 2 0 R>>\nendobj\n2 0 obj\n<</Type/Pages/Kids[]/Count 0>>\nendobj\nxref\n0 3\n0000000000 65535 f \n0000000015 00000 n \n0000000063 00000 n \ntrailer\n<</Size 3/Root 1 0 R>>\nstartxref\n113\n%%EOF\n";
                                                        fileContent = new TextEncoder().encode(pdfHeader).buffer;
                                                    } else {
                                                        // Generic binary placeholder for other formats
                                                        fileContent = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]).buffer;
                                                    }
                                                }
                                                
                                                completedOperations++; // Count the simulated download
                                                progressCallback(completedOperations / totalOperations * 100, `Created placeholder for: ${fileName}`);
                                            }
                                            
                                            // Upload the file to Cloudflare with the correct filename
                                            await this.uploadFile(variationPath, fileName, fileContent);
                                            completedOperations++; // Count the upload operation
                                            progressCallback(completedOperations / totalOperations * 100, `Uploaded file: ${fileName}`);
                                        } catch (assetError) {
                                            console.error(`Error processing asset ${asset.name}:`, assetError);
                                            progressCallback(completedOperations / totalOperations * 100, `Error with asset ${asset.name}: ${assetError.message}`);
                                            
                                            // Increment operations counter even for failed assets to keep progress moving
                                            completedOperations += 2; // Count both download and upload operations
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    // Final completion
                    progressCallback(100, 'Export completed successfully');
                    
                    // Show the share button if it exists
                    const shareBtn = document.getElementById('share-btn');
                    if (shareBtn) {
                        shareBtn.classList.remove('hidden');
                    }
                    
                    return { success: true, message: "Assets have been successfully exported to Cloudflare R2" };
                } catch (error) {
                    console.error('Export to Cloudflare R2 failed:', error);
                    throw new Error(`Export to Cloudflare R2 failed: ${error.message}`);
                }
            }
            
            /**
             * Count the number of folders in the structure
             * @param {Object} structure Nested structure of folders
             * @returns {number} Number of folders
             */
            countFolders(structure) {
                let count = 0;
                
                for (const project in structure) {
                    count++; // Project folder
                    
                    for (const channel in structure[project]) {
                        count++; // Channel folder
                        
                        for (const countryLanguage in structure[project][channel]) {
                            count++; // Country-Language folder
                            
                            for (const variation in structure[project][channel][countryLanguage]) {
                                count++; // Variation folder
                            }
                        }
                    }
                }
                
                return count;
            }
        }

        // Collection management
        const CollectionManager = {
            // Get all collections from storage or API
            getAllCollections: async function() {
                try {
                    // Check if user is authenticated
                    const imsToken = document.getElementById('imsToken').value;
                    
                    if (imsToken) {
                        // If user is authenticated, try to get collections from the API
                        return await this.searchCollectionsFromAPI("");
                    } else {
                        // If not authenticated, show a gentle notification and use sample data
                        showNotification('Sign in with Adobe to access your collections', 'info', 5000);
                        throw new Error("Authentication required");
                    }
                } catch (error) {
                    console.error('Error loading collections from API:', error);
                    
                    // Fall back to local collections if API fails
                    try {
                        const savedCollections = localStorage.getItem('collections');
                        const parsedCollections = savedCollections ? JSON.parse(savedCollections) : [];
                        
                        // Combine saved collections with sample ones
                        return [...parsedCollections, ...sampleCollections];
                    } catch (localError) {
                        console.error('Error loading local collections:', localError);
                        return sampleCollections;  // Ultimate fallback
                    }
                }
            },
            
            // Search collections from Adobe API
            searchCollectionsFromAPI: async function(query) {
                // Base API URL
                const baseApiUrl = 'https://delivery-p108396-e1040009.adobeaemcloud.com';
                const searchEndpoint = `${baseApiUrl}/adobe/assets/search`;
                
                // CORS proxy URL provided
                const corsProxyUrl = 'https://cors-proxy.philipp-koch.workers.dev/corsproxy/?apiurl=';
                
                // Check if CORS proxy is enabled - default to true if not found in config
                let useCorsProxy = true;
                
                // Check the Adobe config to see if using CORS proxy
                const aemConfig = AEMConfig.get();
                if (aemConfig && typeof aemConfig.useCorsProxy !== 'undefined') {
                    useCorsProxy = aemConfig.useCorsProxy;
                }
                
                // Also check the toggle in the UI (which may have changed but not been saved)
                const corsToggle = document.getElementById('use-cors-proxy');
                if (corsToggle) {
                    useCorsProxy = corsToggle.checked;
                }
                
                // Construct the URL based on the CORS proxy setting
                const apiUrl = useCorsProxy 
                    ? corsProxyUrl + encodeURIComponent(searchEndpoint)
                    : searchEndpoint;
                
                // Log for debugging
                console.log(`Making API request to: ${apiUrl} (CORS Proxy: ${useCorsProxy ? 'Enabled' : 'Disabled'})`);
                
                // Get the authentication token - this is the token obtained from Adobe IMS login
                const imsToken = document.getElementById('imsToken').value;
                
                // Check if we have authentication
                if (!imsToken) {
                    throw new Error("Authentication required. Please sign in with Adobe.");
                }
                
                // Ensure token is properly formatted with Bearer prefix
                const formattedToken = imsToken.startsWith('Bearer ') ? imsToken : `Bearer ${imsToken}`;
                
                // Use the specific API key for the Adobe Assets Search API
                const apiKey = 'asset_search_service';
                
                // Prepare the search payload for collections specifically
                const searchPayload = {
                    "requests": [
                        {
                            "indexName": "108396-1040009_collections",
                            "params": {
                                "facets": [],
                                "highlightPostTag": "__/ais-highlight__",
                                "highlightPreTag": "__ais-highlight__",
                                "hitsPerPage": 40,
                                "page": 0,
                                "query": query || "",
                                "tagFilters": ""
                            }
                        }
                    ]
                };
                
                // Make the API request with all required headers
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Adobe-Accept-Experimental': '1',
                        'Authorization': formattedToken,
                        'X-Api-Key': apiKey,
                        'X-Ch-Request': 'search'
                    },
                    body: JSON.stringify(searchPayload)
                });
                
                if (!response.ok) {
                    // Log detailed error information, including the response body if available.
                    const errorText = await response.text();
                    console.error(`API request failed with status ${response.status}: ${errorText}`);
                    throw new Error(`API request failed with status ${response.status}`);
                }
                
                const data = await response.json();
                console.log("Collections search response:", data);
                
                // Process the collections from the hits in the first result
                if (data.results && data.results[0] && data.results[0].hits) {
                    const collectionsHits = data.results[0].hits;
                    
                    // Filter hits to ensure they have a collectionId
                    const validHits = collectionsHits.filter(hit => hit && hit.collectionId);
                    
                    if (validHits.length === 0) {
                        console.warn("No valid collections found in the response");
                        return [];
                    }
                    
                    // Transform the valid hits to our collection format
                    const collections = validHits.map((hit, index) => {
                        const collectionId = hit.collectionId;
                        const shortId = collectionId.substring(0, 8);
                        
                        return {
                            id: index + 1, // Generate a sequential ID
                            collectionId: collectionId, // Store the actual collection ID
                            name: hit.collectionMetadata?.title || `Collection ${shortId}`,
                            description: hit.collectionMetadata?.description || `Collection with ID ${shortId}`,
                            filters: {
                                project: "", // These will be populated when we get collection items
                                channel: "",
                                country: "",
                                language: "",
                                variation: ""
                            }
                        };
                    });
                    
                    console.log(`Found ${collections.length} valid collections`);
                    return collections;
                }
                
                // Return empty array if no collections found
                return [];
            },
            
            // Search for assets within a collection using facetFilters
            // Tracking flag to avoid duplicate API calls
            _isLoadingCollection: false,
            
            searchCollectionAssets: async function(collectionId, filters = {}) {
                // Add extensive logging for tracking API calls
                console.log(`API CALL - Collection: ${collectionId}, Filters:`, JSON.stringify(filters));
                
                // Base API URL
                const baseApiUrl = 'https://delivery-p108396-e1040009.adobeaemcloud.com';
                const searchEndpoint = `${baseApiUrl}/adobe/assets/search`;
                
                // CORS proxy URL provided
                const corsProxyUrl = 'https://cors-proxy.philipp-koch.workers.dev/corsproxy/?apiurl=';
                
                // Check if CORS proxy is enabled - default to true if not found in config
                let useCorsProxy = true;
                
                // Check the Adobe config to see if using CORS proxy
                const aemConfig = AEMConfig.get();
                if (aemConfig && typeof aemConfig.useCorsProxy !== 'undefined') {
                    useCorsProxy = aemConfig.useCorsProxy;
                }
                
                // Also check the toggle in the UI (which may have changed but not been saved)
                const corsToggle = document.getElementById('use-cors-proxy');
                if (corsToggle) {
                    useCorsProxy = corsToggle.checked;
                }
                
                // Construct the URL based on the CORS proxy setting
                const apiUrl = useCorsProxy 
                    ? corsProxyUrl + encodeURIComponent(searchEndpoint)
                    : searchEndpoint;
                
                // Log for debugging
                console.log(`Searching assets in collection: ${collectionId}`);
                
                // Get the authentication token
                const imsToken = document.getElementById('imsToken').value;
                
                // Check if we have authentication
                if (!imsToken) {
                    throw new Error("Authentication required. Please sign in with Adobe.");
                }
                
                // Ensure token is properly formatted with Bearer prefix
                const formattedToken = imsToken.startsWith('Bearer ') ? imsToken : `Bearer ${imsToken}`;
                
                // Use the specific API key for the Adobe Assets Search API
                const apiKey = 'asset_search_service';

                // Extract the UUID part from the collectionId if it contains "urn:cid:aem:"
                const cleanCollectionId = collectionId.includes("urn:cid:aem:") 
                    ? collectionId.replace("urn:cid:aem:", "")
                    : collectionId;
                    
                // Build facet filters array with just the UUID part
                let facetFilters = [[`collectionIds:${cleanCollectionId}`]];
                
                // Add other filters if provided
                const additionalFacets = [];
                
                if (filters.channel) {
                    additionalFacets.push(`gmo-platform:${filters.channel}`);
                }
                
                if (filters.country) {
                    additionalFacets.push(`gmo-p0TargetMarketGeo:${filters.country}`);
                }
                
                if (filters.language) {
                    const langFilter = Array.isArray(filters.language) 
                        ? `dc-language:${filters.language[0]}` 
                        : `dc-language:${filters.language}`;
                    additionalFacets.push(langFilter);
                }
                
                if (filters.variation) {
                    additionalFacets.push(`gmo-namesOfCreativeVariations:${filters.variation}`);
                }
                
                // Add additional facets if there are any
                if (additionalFacets.length > 0) {
                    facetFilters.push(additionalFacets);
                }
                
                // Prepare the search payload
                const searchPayload = {
                    "requests": [
                        {
                            "indexName": "108396-1040009",
                            "params": {
                                "facetFilters": facetFilters,
                                "facets": [
                                    "dc-format-label", 
                                    "dc-language", 
                                    "gmo-campaignName", 
                                    "gmo-contentType", 
                                    "gmo-creativeDescription", 
                                    "gmo-deliverableType", 
                                    "gmo-fiscalYear", 
                                    "gmo-licensedContent", 
                                    "gmo-lineofBusiness", 
                                    "gmo-namesOfCreativeVariations", 
                                    "gmo-p0TargetMarketArea", 
                                    "gmo-p0TargetMarketGeo", 
                                    "gmo-platform", 
                                    "gmo-productsOffering", 
                                    "gmo-programName", 
                                    "repo-modifyDate"
                                ],
                                "filters": "",
                                "highlightPostTag": "__/ais-highlight__",
                                "highlightPreTag": "__ais-highlight__",
                                "hitsPerPage": 100,
                                "maxValuesPerFacet": 10,
                                "page": 0,
                                "query": "",
                                "tagFilters": ""
                            }
                        },
                        {
                            "indexName": "108396-1040009",
                            "params": {
                                "analytics": false,
                                "clickAnalytics": false,
                                "facets": "collectionIds",
                                "filters": "",
                                "highlightPostTag": "__/ais-highlight__",
                                "highlightPreTag": "__ais-highlight__",
                                "hitsPerPage": 0,
                                "maxValuesPerFacet": 10,
                                "page": 0,
                                "query": ""
                            }
                        }
                    ]
                };
                
                // Make the API request with all required headers
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Adobe-Accept-Experimental': '1',
                        'Authorization': formattedToken,
                        'X-Api-Key': apiKey,
                        'X-Ch-Request': 'search'
                    },
                    body: JSON.stringify(searchPayload)
                });
                
                if (!response.ok) {
                    // Log detailed error information, including the response body if available.
                    const errorText = await response.text();
                    console.error(`Collection assets search failed with status ${response.status}: ${errorText}`);
                    throw new Error(`Collection assets search failed with status ${response.status}`);
                }
                
                const data = await response.json();
                console.log("Collection assets search response:", data);
                
                // Process the search results - first result has the assets
                const results = data.results[0];
                
                if (!results || !results.hits || !Array.isArray(results.hits)) {
                    console.warn("No assets found in collection or invalid response format");
                    return {
                        totalAssets: 0,
                        facets: {},
                        assets: []
                    };
                }
                
                // Extract the total count and facets
                const totalAssets = results.nbHits || 0;
                const facets = results.facets || {};
                
                // Transform the assets to our format
                const assets = results.hits.map(hit => {
                    return {
                        id: hit.assetId || hit.objectID || Math.random().toString(36).substring(2, 10),
                        name: hit["dc-title"] || hit["repo-name"] || "Unnamed Asset",
                        type: this.getAssetTypeFromFormat(hit["dc-format-label"]),
                        format: hit["dc-format-label"] || "",
                        project: hit["gmo-campaignName"] || "",
                        channel: hit["gmo-platform"] || "",
                        country: hit["gmo-p0TargetMarketGeo"] || "",
                        language: Array.isArray(hit["dc-language"]) ? hit["dc-language"][0] : hit["dc-language"] || "",
                        countryLanguage: hit["gmo-p0TargetMarketGeo"] 
                            ? `${hit["gmo-p0TargetMarketGeo"]}-${Array.isArray(hit["dc-language"]) ? hit["dc-language"][0] : hit["dc-language"]}`
                            : "gl-en",
                        variation: hit["gmo-namesOfCreativeVariations"] || "Standard",
                        size: hit.size || 0,
                        modifyDate: hit["repo-modifyDate"] || hit["dc-modified"] || "",
                        programName: hit["gmo-programName"] || "",
                        productsOffering: Array.isArray(hit["gmo-productsOffering"]) 
                            ? hit["gmo-productsOffering"][0] 
                            : hit["gmo-productsOffering"] || "",
                        // Additional fields for UI display
                        width: hit["stDim-w"] || 0,
                        height: hit["stDim-h"] || 0,
                        keywords: hit["xcm-machineKeywords"] || []
                    };
                });
                
                return {
                    totalAssets,
                    facets,
                    assets
                };
            },
            
            // Helper method to determine asset type from format label
            getAssetTypeFromFormat: function(formatLabel) {
                if (!formatLabel) return "document";
                
                const format = formatLabel.toLowerCase();
                if (format === "mp4" || format === "quicktime") {
                    return "video";
                } else if (format === "jpeg" || format === "png" || format === "jpg") {
                    return "image";
                } else if (format === "pdf") {
                    return "document";
                } else if (format === "mp3" || format === "wav") {
                    return "audio";
                } else {
                    return "document";
                }
            },
            
            // Get collection items - fetches the assets in a collection
            getCollectionItems: async function(collectionId) {
                // Call the searchCollectionAssets method instead, as it's more reliable
                const result = await this.searchCollectionAssets(collectionId);
                
                return {
                    metadata: { collectionId },
                    assets: result.assets || []
                };
            },
            
            // Helper method to determine asset type from metadata
            getAssetTypeFromMetadata: function(metadata) {
                // Try to determine asset type from format, mimetype, or other fields
                const format = metadata.format || metadata["dc-format"] || "";
                const mimetype = metadata.mimetype || "";
                
                if (format.includes("pdf") || mimetype.includes("pdf")) {
                    return "document";
                } else if (format.includes("jpg") || format.includes("jpeg") || format.includes("png") || 
                           mimetype.includes("image")) {
                    return "image";
                } else if (format.includes("mp4") || format.includes("video") || 
                           mimetype.includes("video")) {
                    return "video";
                } else if (format.includes("mp3") || format.includes("audio") || 
                           mimetype.includes("audio")) {
                    return "audio";
                } else {
                    // Default to document for unknown types
                    return "document";
                }
            },
            
            // Search collections by name or description
            searchCollections: async function(query) {
                try {
                    return await this.searchCollectionsFromAPI(query);
                } catch (error) {
                    console.error('Error searching collections via API:', error);
                    showNotification('Collection search API error, using local data', 'warning');
                    
                    // Fall back to local search if API fails
                    try {
                        const collections = await this.getAllCollections();
                        if (!query) return collections;
                        
                        const lowerQuery = query.toLowerCase();
                        return collections.filter(collection => {
                            return collection.name.toLowerCase().includes(lowerQuery) || 
                                (collection.description && collection.description.toLowerCase().includes(lowerQuery));
                        });
                    } catch (fallbackError) {
                        console.error('Fallback collection search failed:', fallbackError);
                        return [];
                    }
                }
            },
            
            // Current collections cache
            cachedCollections: [],
            
            // Cache collections list when loaded
            cacheCollections: function(collections) {
                this.cachedCollections = collections;
            },
            
            // Get a collection by ID
            getCollectionById: function(id) {
                // First try to find in the cached collections
                const found = this.cachedCollections.find(collection => collection.id === id);
                if (found) {
                    return found;
                }
                
                // If not found in cache, log an error - this shouldn't happen
                console.error(`Collection with ID ${id} not found in cache`);
                return null;
            },
            
            // Current active collection
            activeCollection: null,
            
            // Current collection assets
            currentCollectionAssets: [],
            
            // Current collection facets
            currentCollectionFacets: {},
            
            // Set the active collection and load its assets
            setActiveCollection: async function(collection) {
                console.log('Setting active collection:', collection?.name || 'null');
                
                // IMPORTANT: Prevent duplicate loading of the same collection
                if (this._isLoadingCollection) {
                    console.warn('‚ö†Ô∏è Preventing duplicate collection loading - operation already in progress');
                    return;
                }

                // Set loading flag to true to prevent duplicate calls
                this._isLoadingCollection = true;
                
                this.activeCollection = collection;
                
                if (collection) {
                    // Show loading state
                    const assetsContainer = document.getElementById('assets-container');
                    const assetsCount = document.getElementById('assets-count');
                    assetsContainer.innerHTML = '<div class="col-span-full flex flex-col items-center justify-center py-8"><div class="animate-spin rounded-full h-10 w-10 border-4 border-primary/30 border-t-primary mb-4"></div><div>Loading assets...</div></div>';
                    assetsCount.textContent = 'Loading...';
                    
                    // Update the collection details in the workspace
                    document.getElementById('collection-title').textContent = collection.name;
                    document.getElementById('collection-description').textContent = collection.description || 'No description';
                    
                    // Update breadcrumb
                    document.getElementById('breadcrumb-collection').textContent = collection.name;
                    
                    // Switch to workspace view
                    document.getElementById('welcome-container').classList.add('hidden');
                    document.getElementById('workspace-container').classList.remove('hidden');
                    
                    try {
                        // Check if we have a collection ID (from real API) or using sample data
                        if (collection.collectionId) {
                            console.log('Loading real API collection assets for collection ID:', collection.collectionId);
                            const result = await this.searchCollectionAssets(collection.collectionId);
                            
                            // IMPORTANT: Check if we actually got assets back, and only proceed if we did
                            if (result.assets && result.assets.length > 0) {
                                console.log('Successfully loaded assets from API, count:', result.assets.length);
                                
                                // Store the assets and facets for later use
                                this.currentCollectionAssets = result.assets;
                                this.currentCollectionFacets = result.facets;
                                
                                // Update the filter dropdowns from facets
                                this.populateFiltersFromFacets(result.facets);
                                console.log('Updated filter dropdowns from facets');
                                
                                // Display the assets and folder structure
                                console.log('About to display assets...');
                                displayAssets(result.assets);
                                console.log('Assets display completed');
                                generateFolderStructure(result.assets);
                                console.log('Folder structure generated');
                            } else {
                                console.warn('‚ö†Ô∏è API returned zero assets! Preserving previously loaded assets');
                                
                                // Still store the facets even if there are no assets
                                if (result.facets) {
                                    this.currentCollectionFacets = result.facets;
                                    this.populateFiltersFromFacets(result.facets);
                                    console.log('Updated filter dropdowns from facets, despite no assets');
                                }
                                
                                // If we have previously loaded assets, keep showing them
                                if (this.currentCollectionAssets && this.currentCollectionAssets.length > 0) {
                                    console.log('Displaying previously loaded assets:', this.currentCollectionAssets.length);
                                    displayAssets(this.currentCollectionAssets);
                                    generateFolderStructure(this.currentCollectionAssets);
                                } else if (window._lastLoadedAssets && window._lastLoadedAssets.length > 0) {
                                    // Last resort - use the recovery variable if available
                                    console.log('Using recovered assets:', window._lastLoadedAssets.length);
                                    displayAssets(window._lastLoadedAssets);
                                    generateFolderStructure(window._lastLoadedAssets);
                                    
                                    // Show a notification about the recovery
                                    showNotification('Automatically recovered assets from previous view', 'info');
                                } else {
                                    // Show an empty state if we have no assets to show
                                    displayAssets([]);
                                    generateFolderStructure([]);
                                }
                            }
                        } else {
                            // We're using sample data
                            console.log('Using sample data from local storage');
                            const filtered = filterAssets();
                            console.log('Filtered sample assets, count:', filtered.length);
                            displayAssets(filtered);
                            console.log('Sample assets displayed');
                            generateFolderStructure(filtered);
                            console.log('Sample folder structure generated');
                        }
                    } catch (error) {
                        console.error('Error loading collection assets:', error);
                        assetsContainer.innerHTML = '<div class="col-span-full text-center text-red-500 dark:text-red-400 py-4">Error loading assets. Please try again.</div>';
                        assetsCount.textContent = 'Error loading assets';
                        
                        // Show notification about the error
                        showNotification('Failed to load collection assets: ' + error.message, 'error');
                    } finally {
                        // IMPORTANT: Always reset the loading flag when done, even in case of errors
                        // This prevents the app from getting stuck in a loading state if an error occurs
                        this._isLoadingCollection = false;
                        console.log('Collection loading flag reset');
                    }
                }
            },
            
            // Populate filter dropdowns from facets in the API response
            populateFiltersFromFacets: function(facets) {
                // Channel/Platform filter
                const platformValues = facets['gmo-platform'] || {};
                const channelSelect = document.getElementById('channel');
                channelSelect.innerHTML = '<option value="">All Channels</option>';
                
                Object.keys(platformValues).sort().forEach(platform => {
                    const option = document.createElement('option');
                    option.value = platform;
                    option.textContent = `${platform} (${platformValues[platform]})`;
                    channelSelect.appendChild(option);
                });
                
                // Country/Market Geo filter
                const countryValues = facets['gmo-p0TargetMarketGeo'] || {};
                const countrySelect = document.getElementById('country');
                countrySelect.innerHTML = '<option value="">All Countries</option>';
                
                Object.keys(countryValues).sort().forEach(country => {
                    const option = document.createElement('option');
                    option.value = country;
                    option.textContent = `${country} (${countryValues[country]})`;
                    countrySelect.appendChild(option);
                });
                
                // Language filter
                const languageValues = facets['dc-language'] || {};
                const languageSelect = document.getElementById('language');
                languageSelect.innerHTML = '<option value="">All Languages</option>';
                
                Object.keys(languageValues).sort().forEach(language => {
                    const option = document.createElement('option');
                    option.value = language;
                    option.textContent = `${language} (${languageValues[language]})`;
                    languageSelect.appendChild(option);
                });
                
                // Variation filter
                const variationValues = facets['gmo-namesOfCreativeVariations'] || {};
                const variationSelect = document.getElementById('variation');
                variationSelect.innerHTML = '<option value="">All Variations</option>';
                
                Object.keys(variationValues).sort().forEach(variation => {
                    const option = document.createElement('option');
                    option.value = variation;
                    option.textContent = `${variation} (${variationValues[variation]})`;
                    variationSelect.appendChild(option);
                });
            },
            
            // Update filter dropdowns from facets while preserving currently selected values
            updateFiltersFromFacets: function(facets, currentFilters = {}) {
                // Store the currently selected values
                const selectedChannel = currentFilters.channel || '';
                const selectedCountry = currentFilters.country || '';
                const selectedLanguage = currentFilters.language || '';
                const selectedVariation = currentFilters.variation || '';
                
                // Channel/Platform filter
                const platformValues = facets['gmo-platform'] || {};
                const channelSelect = document.getElementById('channel');
                channelSelect.innerHTML = '<option value="">All Channels</option>';
                
                // Add each channel option, marking the current selection
                Object.keys(platformValues).sort().forEach(platform => {
                    const option = document.createElement('option');
                    option.value = platform;
                    option.textContent = `${platform} (${platformValues[platform]})`;
                    if (platform === selectedChannel) {
                        option.selected = true;
                    }
                    channelSelect.appendChild(option);
                });
                
                // If the selected value is no longer in options, add it back
                if (selectedChannel && !Object.keys(platformValues).includes(selectedChannel)) {
                    const option = document.createElement('option');
                    option.value = selectedChannel;
                    option.textContent = `${selectedChannel} (0)`;
                    option.selected = true;
                    channelSelect.appendChild(option);
                }
                
                // Country/Market Geo filter - follow same pattern as above
                const countryValues = facets['gmo-p0TargetMarketGeo'] || {};
                const countrySelect = document.getElementById('country');
                countrySelect.innerHTML = '<option value="">All Countries</option>';
                
                Object.keys(countryValues).sort().forEach(country => {
                    const option = document.createElement('option');
                    option.value = country;
                    option.textContent = `${country} (${countryValues[country]})`;
                    if (country === selectedCountry) {
                        option.selected = true;
                    }
                    countrySelect.appendChild(option);
                });
                
                if (selectedCountry && !Object.keys(countryValues).includes(selectedCountry)) {
                    const option = document.createElement('option');
                    option.value = selectedCountry;
                    option.textContent = `${selectedCountry} (0)`;
                    option.selected = true;
                    countrySelect.appendChild(option);
                }
                
                // Language filter
                const languageValues = facets['dc-language'] || {};
                const languageSelect = document.getElementById('language');
                languageSelect.innerHTML = '<option value="">All Languages</option>';
                
                Object.keys(languageValues).sort().forEach(language => {
                    const option = document.createElement('option');
                    option.value = language;
                    option.textContent = `${language} (${languageValues[language]})`;
                    if (language === selectedLanguage) {
                        option.selected = true;
                    }
                    languageSelect.appendChild(option);
                });
                
                if (selectedLanguage && !Object.keys(languageValues).includes(selectedLanguage)) {
                    const option = document.createElement('option');
                    option.value = selectedLanguage;
                    option.textContent = `${selectedLanguage} (0)`;
                    option.selected = true;
                    languageSelect.appendChild(option);
                }
                
                // Variation filter
                const variationValues = facets['gmo-namesOfCreativeVariations'] || {};
                const variationSelect = document.getElementById('variation');
                variationSelect.innerHTML = '<option value="">All Variations</option>';
                
                Object.keys(variationValues).sort().forEach(variation => {
                    const option = document.createElement('option');
                    option.value = variation;
                    option.textContent = `${variation} (${variationValues[variation]})`;
                    if (variation === selectedVariation) {
                        option.selected = true;
                    }
                    variationSelect.appendChild(option);
                });
                
                if (selectedVariation && !Object.keys(variationValues).includes(selectedVariation)) {
                    const option = document.createElement('option');
                    option.value = selectedVariation;
                    option.textContent = `${selectedVariation} (0)`;
                    option.selected = true;
                    variationSelect.appendChild(option);
                }
            }
        };

        // Simple storage functions without encryption
        const Crypto = {
            // For future compatibility, we keep the same API but don't actually encrypt
            encrypt: function(text) {
                return text || '';
            },
            
            decrypt: function(encrypted) {
                return encrypted || '';
            }
        };

        // Default configuration values
        const DEFAULT_CONFIG = {
            url: 'https://storage-srv.philipp-koch.workers.dev',
            apiKey: 'super-secret-key',
            folder: 'gmo-assets'
        };
        
        // Cloudflare configuration management
        const CloudflareConfig = {
            get: function() {
                try {
                    const config = localStorage.getItem('cloudflareConfig');
                    if (!config) return null;
                    
                    const parsedConfig = JSON.parse(config);
                    
                    // Decrypt the API key if it exists
                    if (parsedConfig.apiKey) {
                        parsedConfig.apiKey = Crypto.decrypt(parsedConfig.apiKey);
                    }
                    
                    return parsedConfig;
                } catch (error) {
                    console.error('Error retrieving Cloudflare config:', error);
                    return null;
                }
            },
            
            save: function(config, remember = false) {
                // Make a copy to avoid modifying the original
                const configToSave = { ...config };
                
                // Encrypt the API key
                if (configToSave.apiKey) {
                    configToSave.apiKey = Crypto.encrypt(configToSave.apiKey);
                }
                
                if (remember) {
                    try {
                        localStorage.setItem('cloudflareConfig', JSON.stringify(configToSave));
                    } catch (error) {
                        console.error('Error saving Cloudflare config:', error);
                        showError('Failed to save configuration: ' + error.message);
                    }
                } else {
                    // Store in memory only
                    this.currentConfig = config; // Store unencrypted version in memory
                    try {
                        localStorage.removeItem('cloudflareConfig');
                    } catch (error) {
                        console.error('Error removing Cloudflare config:', error);
                    }
                }
                
                // Update UI mode indicator
                updateModeIndicator();
            },
            
            clear: function() {
                this.currentConfig = null;
                try {
                    localStorage.removeItem('cloudflareConfig');
                } catch (error) {
                    console.error('Error clearing Cloudflare config:', error);
                }
                
                // Update UI mode indicator
                updateModeIndicator();
            },
            
            isConfigured: function() {
                const config = this.get() || this.currentConfig;
                return !!(config && config.url && config.apiKey);
            },
            
            getDefault: function() {
                return { ...DEFAULT_CONFIG };
            },
            
            currentConfig: null
        };

        // Adobe Experience Manager configuration management
        const AEMConfig = {
            get: function() {
                try {
                    const config = localStorage.getItem('aemConfig');
                    return config ? JSON.parse(config) : null;
                } catch (error) {
                    console.error('Error retrieving AEM config:', error);
                    return null;
                }
            },
            
            save: function(config) {
                try {
                    localStorage.setItem('aemConfig', JSON.stringify(config));
                } catch (error) {
                    console.error('Error saving AEM config:', error);
                    showError('Failed to save AEM configuration: ' + error.message);
                }
            },
            
            isConfigured: function() {
                const config = this.get();
                return !!(config && config.endpoint);
            }
        };

        // Function to initiate IMS login flow
        function loginWithIMS() {
            // Create and show the auth loading indicator
            const authLoadingIndicator = document.createElement('div');
            authLoadingIndicator.id = 'authLoadingIndicator';
            authLoadingIndicator.className = 'fixed inset-0 bg-white/50 dark:bg-gray-900/50 flex flex-col justify-center items-center z-50';
            authLoadingIndicator.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg flex flex-col items-center">
                    <div class="animate-spin rounded-full h-12 w-12 border-4 border-primary/30 border-t-4 border-t-primary mb-4"></div>
                    <p class="text-lg font-medium">Preparing Adobe Authentication...</p>
                    <p class="text-sm text-gray-500 dark:text-gray-400 mt-2">Please wait while we connect to Adobe's authentication service</p>
                </div>
            `;
            document.body.appendChild(authLoadingIndicator);
            
            // Save current app state to restore after authentication
            const currentState = {
                apiEndpoint: document.getElementById('apiEndpoint').value,
                apiKey: document.getElementById('apiKey').value,
                limitResults: document.getElementById('limitResults').value
            };
            
            // Store current state in memory so we can retrieve it later
            window.imsState = currentState;
            
            // Create the authorization URL
            const authUrl = `https://ims-na1.adobelogin.com/ims/authorize/v2?` +
                `client_id=${encodeURIComponent(imsConfig.clientId)}` +
                `&redirect_uri=${encodeURIComponent(imsConfig.redirectUri)}` +
                `&scope=${encodeURIComponent(imsConfig.scope)}` +
                `&response_type=${imsConfig.responseType}`;
            
            // Delay opening the window to give the user time to see the loading indicator
            setTimeout(() => {
                // Store the auth window reference globally to close it later
                window.authWindow = window.open(authUrl, 'adobeImsLogin', 
                    'width=800,height=600,location=yes,resizable=yes,scrollbars=yes,status=yes');
                
                if (!window.authWindow) {
                    // Remove the loading indicator
                    if (document.body.contains(authLoadingIndicator)) {
                        document.body.removeChild(authLoadingIndicator);
                    }
                    showNotification('Popup blocked. Please allow popups for this site and try again.', 'error');
                    return;
                }
                
                // Update the loading indicator message after opening the window
                const loadingText = authLoadingIndicator.querySelector('p.text-lg');
                const loadingSubtext = authLoadingIndicator.querySelector('p.text-sm');
                if (loadingText && loadingSubtext) {
                    loadingText.textContent = 'Adobe Authentication Window Opened';
                    loadingSubtext.textContent = 'Please complete the sign in process in the popup window';
                }
                
                // Remove loading indicator after a longer delay to ensure user notices it
                setTimeout(() => {
                    if (document.body.contains(authLoadingIndicator)) {
                        document.body.removeChild(authLoadingIndicator);
                    }
                    // Show a helper notification to guide users
                    showNotification('Adobe login window opened. Please complete authentication in the popup.', 'info', 10000);
                }, 1500);
                
                // Handle message events from the popup
                window.addEventListener('message', receiveImsToken, false);
                
                // Function to monitor for popup closure with a longer interval
                const checkClosed = setInterval(() => {
                    if (window.authWindow && window.authWindow.closed) {
                        clearInterval(checkClosed);
                        window.removeEventListener('message', receiveImsToken);
                        
                        // Show loading when checking for token
                        const tokenCheckIndicator = document.createElement('div');
                        tokenCheckIndicator.className = 'fixed inset-0 bg-white/50 dark:bg-gray-900/50 flex flex-col justify-center items-center z-50';
                        tokenCheckIndicator.innerHTML = `
                            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg flex flex-col items-center">
                                <div class="animate-spin rounded-full h-12 w-12 border-4 border-primary/30 border-t-4 border-t-primary mb-4"></div>
                                <p class="text-lg font-medium">Processing Authentication</p>
                                <p class="text-sm text-gray-500 dark:text-gray-400 mt-2">Retrieving your access token...</p>
                            </div>
                        `;
                        document.body.appendChild(tokenCheckIndicator);
                        
                        // Add a longer delay before checking for the token to give more time for processing
                        setTimeout(() => {
                            // Check if we have a token in the URL hash (in case the popup redirected to our main window)
                            const hasToken = handleImsRedirect();
                            
                            // Remove the token check indicator
                            if (document.body.contains(tokenCheckIndicator)) {
                                document.body.removeChild(tokenCheckIndicator);
                            }
                            
                            // If we don't have a token yet, prompt the user to enter it manually
                            const imsTokenField = document.getElementById('imsToken');
                            if (!hasToken && !imsTokenField.value) {
                                // Show manual token entry helper
                                showManualTokenHelper();
                            }
                        }, 2000); // Wait 2 seconds before checking for token
                    }
                }, 1000); // Check every second if the popup is closed
            }, 800); // Wait 800ms before opening the authentication window
        }

        // Generate a read-only view link based on the current configuration
        function generateReadOnlyViewLink() {
            // Get the current Cloudflare configuration
            const config = CloudflareConfig.get() || CloudflareConfig.currentConfig;
            
            // Use AEM page URL as the base instead of the Poe URL
            // This is the dedicated AEM page that will serve as the viewer UI
            const viewerUrl = "https://main--poe-playground--pkoch73.aem.page/tools/asset-packager-share/index.html";
            
            // Get collection info
            const activeCollection = CollectionManager.activeCollection;
            const collectionName = activeCollection ? encodeURIComponent(activeCollection.name) : "collection";
            
            // Build the storage API URL - this is the actual Cloudflare storage URL
            // IMPORTANT: Include the /list path segment for the Asset Viewer
            let storageApiUrl = "";
            if (config && config.url) {
                // Ensure the URL doesn't already have /list at the end
                const baseUrl = config.url.endsWith('/list') ? config.url : 
                                (config.url.endsWith('/') ? config.url + 'list' : config.url + '/list');
                storageApiUrl = encodeURIComponent(baseUrl);
            } else {
                // Demo mode - use placeholder URL with /list
                storageApiUrl = encodeURIComponent("https://storage-demo.workers.dev/list");
            }
            
            // Build the URL with parameters
            let viewUrl = `${viewerUrl}?storageUrl=${storageApiUrl}`;
            viewUrl += `&collection=${collectionName}`;
            
            // Add API key (encrypted or hashed in a real implementation)
            if (config && config.apiKey) {
                // In a real implementation, you would want to use a view-only API key
                // or implement a token system rather than sharing the full API key
                viewUrl += `&key=${encodeURIComponent(config.apiKey)}`;
            }
            
            // Add base folder if available
            if (config && config.folder) {
                viewUrl += `&base=${encodeURIComponent(config.folder)}`;
            }
            
            // Add a timestamp to make the URL unique
            viewUrl += `&t=${Date.now()}`;
            
            return viewUrl;
        }
        
        // Update the read-only view link in the success modal
        function updateReadOnlyViewLink() {
            const viewLink = generateReadOnlyViewLink();
            document.getElementById('readonly-view-link').value = viewLink;
        }
        
        // Copy the read-only view link to clipboard
        function copyReadOnlyViewLink() {
            const linkInput = document.getElementById('readonly-view-link');
            linkInput.select();
            
            try {
                document.execCommand('copy');
                
                // Show feedback
                const copyBtn = document.getElementById('copy-readonly-link');
                const originalHTML = copyBtn.innerHTML;
                
                copyBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
                    </svg>
                    Copied!
                `;
                
                setTimeout(() => {
                    copyBtn.innerHTML = originalHTML;
                }, 2000);
                
                // Show a notification
                showNotification('Read-only view link copied to clipboard!', 'success', 3000);
            } catch (err) {
                console.error('Failed to copy link: ', err);
                showNotification('Failed to copy link', 'error');
            }
        }
        
        // Open the read-only viewer in a new tab
        function openReadOnlyViewer() {
            const viewLink = document.getElementById('readonly-view-link').value;
            window.open(viewLink, '_blank');
        }
        
        // Function to handle IMS auth response
        function receiveImsToken(event) {
            // Only accept messages from Adobe domains
            if (!event.origin.includes('adobe.com')) {
                return;
            }
            
            try {
                // Parse the received data
                const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
                console.log('IMS Response Data:', JSON.stringify(data, null, 2));
                
                // Check if this is an IMS auth response with access token
                if (data && data.access_token) {
                    // Format the token properly with 'Bearer' prefix
                    const token = `Bearer ${data.access_token}`;
                    
                    // Update the IMS token input field
                    document.getElementById('imsToken').value = token;
                    
                    // Restore application state if we saved it
                    if (window.imsState) {
                        document.getElementById('apiEndpoint').value = window.imsState.apiEndpoint;
                        document.getElementById('apiKey').value = window.imsState.apiKey;
                        document.getElementById('limitResults').value = window.imsState.limitResults;
                    }
                    
                    // IMMEDIATELY hide auth panel and sign-in button
                    const authPanel = document.getElementById('auth-panel');
                    const signInBtn = document.getElementById('signInBtn');
                    
                    if (authPanel) authPanel.classList.add('hidden');
                    if (signInBtn) signInBtn.classList.add('hidden');
                    
                    // Update auth status in settings panel
                    updateAuthStatusUI(true);
                    
                    // Show a success message
                    showNotification('Successfully authenticated with Adobe IMS', 'success');
                    
                    // Close the authentication window if it's still open
                    if (window.authWindow && !window.authWindow.closed) {
                        window.authWindow.close();
                    }
                }
            } catch (error) {
                console.error('Error processing IMS response:', error);
                showNotification('Error authenticating with Adobe IMS', 'error');
            }
        }

        // Function to update the authentication status UI
        function updateAuthStatusUI(isAuthenticated) {
            const authStatus = document.getElementById('authStatus');
            const authPanel = document.getElementById('auth-panel');
            const signInBtn = document.getElementById('signInBtn');
            
            if (isAuthenticated) {
                // Hide the authentication panel completely when authenticated
                if (authPanel) {
                    authPanel.classList.add('hidden');
                }
                
                // Hide sign in button when authenticated
                if (signInBtn) {
                    signInBtn.classList.add('hidden');
                }
                
                // Update the Adobe status in settings
                const adobeAuthStatus = document.getElementById('adobe-auth-status');
                if (adobeAuthStatus) {
                    adobeAuthStatus.textContent = 'Authentication successful. You are now signed in.';
                    adobeAuthStatus.className = 'mb-2 text-green-600 dark:text-green-400';
                }
                
                // Show user info if available
                document.getElementById('adobe-user-info').classList.remove('hidden');
                document.getElementById('adobe-username').textContent = 'Adobe User';
                document.getElementById('adobe-org').textContent = 'Your Organization';
                document.getElementById('adobe-token-expires').textContent = 'In 24 hours';
            } else {
                // Show authentication panel when not authenticated
                if (authPanel) {
                    authPanel.classList.remove('hidden');
                }
                
                // Show sign in button when not authenticated
                if (signInBtn) {
                    signInBtn.classList.remove('hidden');
                }
                
                if (authStatus) {
                    authStatus.innerHTML = `
                        <span class="text-red-500 dark:text-red-400 flex items-center">
                            <i class="fas fa-circle text-xs mr-2"></i>Not signed in
                        </span>
                    `;
                }
                
                // Update the Adobe status in settings
                const adobeAuthStatus = document.getElementById('adobe-auth-status');
                if (adobeAuthStatus) {
                    adobeAuthStatus.textContent = 'Not authenticated. Use the "Sign in with Adobe" button to connect.';
                    adobeAuthStatus.className = 'mb-2';
                }
                
                // Hide user info section
                document.getElementById('adobe-user-info').classList.add('hidden');
            }
        }

        // Check if we have a hash fragment from an IMS redirect
        function handleImsRedirect() {
            // Check if we have a hash in the URL
            if (window.location.hash) {
                try {
                    // Parse the hash fragment
                    const params = new URLSearchParams(window.location.hash.substring(1));
                    const accessToken = params.get('access_token');
                    
                    if (accessToken) {
                        // Format the token with 'Bearer' prefix
                        const token = `Bearer ${accessToken}`;
                        
                        // Set token in the field
                        document.getElementById('imsToken').value = token;
                        
                        // IMMEDIATELY hide auth panel and sign-in button
                        const authPanel = document.getElementById('auth-panel');
                        const signInBtn = document.getElementById('signInBtn');
                        
                        if (authPanel) authPanel.classList.add('hidden');
                        if (signInBtn) signInBtn.classList.add('hidden');
                        
                        // Clear the hash from the URL
                        history.replaceState(null, null, ' ');
                        
                        // Update auth status in settings
                        updateAuthStatusUI(true);
                        
                        // Show success message
                        showNotification('Successfully authenticated with Adobe IMS', 'success');
                        
                        // Close the authentication window if it's still open
                        if (window.authWindow && !window.authWindow.closed) {
                            window.authWindow.close();
                        }
                        
                        return true; // Indicate that we found and processed a token
                    }
                } catch (error) {
                    console.error('Error handling IMS redirect:', error);
                }
            }
            return false; // Indicate that we did not find a token
        }

        // Function to show a manual token entry helper
        function showManualTokenHelper() {
            const helper = document.createElement('div');
            helper.className = 'fixed inset-0 bg-black/70 flex items-center justify-center z-50';
            helper.innerHTML = `
                <div class="bg-white dark:bg-gray-800 w-full max-w-2xl rounded-lg overflow-hidden shadow-xl p-6">
                    <h3 class="text-xl font-bold mb-4">Adobe Authentication Help</h3>
                    <p class="mb-4">The authentication window was closed, but we couldn't automatically retrieve your token.</p>
                    
                    <div class="bg-yellow-50 dark:bg-yellow-900/20 border-l-4 border-yellow-500 p-4 mb-4">
                        <p class="font-medium mb-2">To complete authentication:</p>
                        <ol class="list-decimal ml-5 space-y-2">
                            <li>If you completed authentication in the popup window, check the address bar in that window.</li>
                            <li>Look for a URL that starts with your current domain and has <code class="bg-gray-200 dark:bg-gray-700 px-1 rounded">access_token=</code> in it.</li>
                            <li>Copy the entire <code class="bg-gray-200 dark:bg-gray-700 px-1 rounded">access_token</code> value (the long string after the equals sign).</li>
                            <li>Paste it in the field below, and click "Use Token".</li>
                        </ol>
                    </div>
                    
                    <div class="mb-4">
                        <label for="manualToken" class="block mb-1 font-medium">Access Token</label>
                        <input type="text" id="manualToken" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-base" 
                            placeholder="Paste your access_token here">
                    </div>
                    
                    <div class="flex justify-end space-x-3">
                        <button id="cancelTokenHelperBtn" class="px-4 py-2 bg-gray-200 hover:bg-gray-300 text-gray-800 rounded-md">
                            Cancel
                        </button>
                        <button id="useManualTokenBtn" class="px-4 py-2 bg-primary hover:bg-secondary text-white rounded-md">
                            Use Token
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(helper);
            
            // Add event listeners
            document.getElementById('cancelTokenHelperBtn').addEventListener('click', () => {
                document.body.removeChild(helper);
            });
            
            document.getElementById('useManualTokenBtn').addEventListener('click', () => {
                const manualToken = document.getElementById('manualToken').value.trim();
                if (manualToken) {
                    // Format the token with Bearer prefix if it doesn't have it
                    const token = manualToken.startsWith('Bearer ') ? manualToken : `Bearer ${manualToken}`;
                    document.getElementById('imsToken').value = token;
                    
                    // IMMEDIATELY hide auth panel and sign-in button
                    const authPanel = document.getElementById('auth-panel');
                    const signInBtn = document.getElementById('signInBtn');
                    
                    if (authPanel) authPanel.classList.add('hidden');
                    if (signInBtn) signInBtn.classList.add('hidden');
                    
                    showNotification('Token applied successfully!', 'success');
                    document.body.removeChild(helper);
                    
                    // Update auth status UI
                    updateAuthStatusUI(true);
                } else {
                    showNotification('Please enter a valid token', 'error');
                }
            });
            
            // Focus the input field
            setTimeout(() => {
                document.getElementById('manualToken').focus();
            }, 100);
        }

        // Get Cloudflare service instance
        function getCloudflareService() {
            const config = CloudflareConfig.get() || CloudflareConfig.currentConfig;
            if (!config) return null;
            
            return new CloudflareService(config);
        }

        // Update mode indicator based on Cloudflare config
        function updateModeIndicator() {
            const modeIndicator = document.getElementById('mode-indicator');
            
            if (CloudflareConfig.isConfigured()) {
                modeIndicator.textContent = 'Cloudflare Mode';
                modeIndicator.classList.remove('bg-yellow-100', 'text-yellow-800', 'dark:bg-yellow-900', 'dark:text-yellow-200');
                modeIndicator.classList.add('bg-green-100', 'text-green-800', 'dark:bg-green-900', 'dark:text-green-200');
            } else {
                modeIndicator.textContent = 'Demo Mode';
                modeIndicator.classList.remove('bg-green-100', 'text-green-800', 'dark:bg-green-900', 'dark:text-green-200');
                modeIndicator.classList.add('bg-yellow-100', 'text-yellow-800', 'dark:bg-yellow-900', 'dark:text-yellow-200');
            }
        }

        // Extract unique values for filter dropdowns
        function populateFilterDropdowns() {
            const filters = {
                channel: new Set(),
                country: new Set(),
                language: new Set(),
                variation: new Set()
            };
            
            contentHubAssets.forEach(asset => {
                filters.channel.add(asset.channel);
                filters.country.add(asset.country);
                filters.language.add(asset.language);
                filters.variation.add(asset.variation);
            });
            
            // Populate channel dropdown
            const channelSelect = document.getElementById('channel');
            channelSelect.innerHTML = '<option value="">All Channels</option>';
            Array.from(filters.channel).sort().forEach(channel => {
                const option = document.createElement('option');
                option.value = channel;
                option.textContent = channel;
                channelSelect.appendChild(option);
            });
            
            // Populate country dropdown
            const countrySelect = document.getElementById('country');
            countrySelect.innerHTML = '<option value="">All Countries</option>';
            Array.from(filters.country).sort().forEach(country => {
                const option = document.createElement('option');
                option.value = country;
                option.textContent = country;
                countrySelect.appendChild(option);
            });
            
            // Populate language dropdown
            const languageSelect = document.getElementById('language');
            languageSelect.innerHTML = '<option value="">All Languages</option>';
            Array.from(filters.language).sort().forEach(language => {
                const option = document.createElement('option');
                option.value = language;
                option.textContent = language;
                languageSelect.appendChild(option);
            });
            
            // Populate variation dropdown
            const variationSelect = document.getElementById('variation');
            variationSelect.innerHTML = '<option value="">All Variations</option>';
            Array.from(filters.variation).sort().forEach(variation => {
                const option = document.createElement('option');
                option.value = variation;
                option.textContent = variation;
                variationSelect.appendChild(option);
            });
        }

        // Apply filters from a collection
        function applyCollectionFilters(collection) {
            if (!collection || !collection.filters) return;
            
            // Note: project filter is handled internally now
            document.getElementById('channel').value = collection.filters.channel || '';
            document.getElementById('country').value = collection.filters.country || '';
            document.getElementById('language').value = collection.filters.language || '';
            document.getElementById('variation').value = collection.filters.variation || '';
            
            // Set as active collection
            CollectionManager.setActiveCollection(collection);
            
            // Update UI with filtered assets
            updateUI();
        }

        // Clear collection and return to welcome screen
        function clearCollectionSelection() {
            CollectionManager.activeCollection = null;
            
            // Return to welcome screen
            document.getElementById('workspace-container').classList.add('hidden');
            document.getElementById('welcome-container').classList.remove('hidden');
        }

        // Get current filters from form
        function getCurrentFilters() {
            return {
                project: activeCollection && activeCollection.filters ? activeCollection.filters.project : '',
                channel: document.getElementById('channel').value || '',
                country: document.getElementById('country').value || '',
                language: document.getElementById('language').value || '',
                variation: document.getElementById('variation').value || ''
            };
        }

        // Populate collections list in the welcome screen
        function populateWelcomeCollectionsList(collections) {
            const collectionsList = document.getElementById('collections-list-welcome');
            collectionsList.innerHTML = '';
            
            if (collections.length === 0) {
                collectionsList.innerHTML = '<li class="text-gray-500 dark:text-gray-400 p-4 text-center">No collections found</li>';
                return;
            }
            
            collections.forEach(collection => {
                const listItem = document.createElement('li');
                listItem.className = 'p-3 hover:bg-gray-100 dark:hover:bg-gray-600 rounded-md mb-2 cursor-pointer border border-gray-200 dark:border-gray-700';
                listItem.dataset.id = collection.id;
                
                listItem.innerHTML = `
                    <div class="flex items-start">
                        <div class="text-primary mr-3 mt-1">
                            <i class="fas fa-folder text-lg"></i>
                        </div>
                        <div class="flex-1">
                            <div class="font-medium">${collection.name}</div>
                            <div class="text-sm text-gray-500 dark:text-gray-400 mt-1 line-clamp-2">${collection.description || 'No description'}</div>
                            <div class="text-xs text-gray-400 dark:text-gray-500 mt-2 flex items-center">
                                <i class="fas fa-filter mr-1"></i>
                                <span class="truncate">
                                    ${collection.filters.project ? collection.filters.project : 'All projects'}
                                    ${collection.filters.channel ? '¬∑ ' + collection.filters.channel : ''}
                                </span>
                            </div>
                        </div>
                    </div>
                `;
                
                listItem.addEventListener('click', () => {
                    const collection = CollectionManager.getCollectionById(parseInt(listItem.dataset.id));
                    applyCollectionFilters(collection);
                });
                
                collectionsList.appendChild(listItem);
            });
        }

        // Filter assets based on selected criteria
        function filterAssets() {
            // Get active collection
            const activeCollection = CollectionManager.activeCollection;
            
            // Check if we're using API-fetched assets or demo assets
            if (activeCollection && activeCollection.collectionId && CollectionManager.currentCollectionAssets.length > 0) {
                // For real API assets, we can use the assets already fetched and loaded
                // We filter the already-retrieved assets based on current filters
                const channel = document.getElementById('channel').value;
                const country = document.getElementById('country').value;
                const language = document.getElementById('language').value;
                const variation = document.getElementById('variation').value;
                
                return CollectionManager.currentCollectionAssets.filter(asset => {
                    return (channel === '' || asset.channel === channel) &&
                           (country === '' || asset.country === country) &&
                           (language === '' || asset.language === language) &&
                           (variation === '' || asset.variation === variation);
                });
            } else {
                // For demo assets, we use the contentHubAssets as before
                const project = activeCollection && activeCollection.filters.project ? activeCollection.filters.project : '';
                const channel = document.getElementById('channel').value;
                const country = document.getElementById('country').value;
                const language = document.getElementById('language').value;
                const variation = document.getElementById('variation').value;
                
                return contentHubAssets.filter(asset => {
                    return (project === '' || asset.project === project) &&
                           (channel === '' || asset.channel === channel) &&
                           (country === '' || asset.country === country) &&
                           (language === '' || asset.language === language) &&
                           (variation === '' || asset.variation === variation);
                });
            }
        }

        // Global variable to store the last successfully loaded assets
        window._lastLoadedAssets = [];
        
        // Display assets in the assets container with thumbnails when available
        function displayAssets(assets) {
            const assetsContainer = document.getElementById('assets-container');
            const assetsCount = document.getElementById('assets-count');
            
            // Add logging to track asset display
            console.log('displayAssets called with', assets.length, 'assets');
            
            // Store assets for recovery
            if (assets && assets.length > 0) {
                window._lastLoadedAssets = [...assets];
                console.log('Saved assets to recovery variable');
            }
            
            // Safety check - only clear if we have new assets to show
            if (assetsContainer.innerHTML === '' || assets.length > 0) {
                assetsContainer.innerHTML = '';
                assetsCount.textContent = `Showing ${assets.length} assets`;
                
                if (assets.length === 0) {
                    assetsContainer.innerHTML = '<div class="col-span-full text-center py-4 text-gray-500 dark:text-gray-400">No assets match the selected filters</div>';
                    return;
                }
            } else {
                console.log('‚ö†Ô∏è Prevented assets container from being cleared when it already has content');
            }
            
            assets.forEach(asset => {
                const assetCard = document.createElement('div');
                assetCard.className = 'bg-gray-50 dark:bg-gray-700 p-3 rounded-md border border-gray-200 dark:border-gray-600';
                
                // Use emoji icons for consistency
                const icon = fileTypeIcons[asset.type] || 'üìÅ';
                
                // Determine if a preview is available
                let previewHtml = '';
                const isImage = asset.type === 'image';
                const isVideo = asset.type === 'video';
                
                // For images, create a preview area with actual image thumbnail
                if (isImage) {
                    // Check if asset has ID that can be used for preview URL
                    if (asset.id && typeof asset.id === 'string' && asset.id.includes('urn:aaid:aem:')) {
                        // Format: https://delivery-p108396-e1040009.adobeaemcloud.com/adobe/assets/[assetId]/as/preview-[filename].jpg?width=350&preferwebp=true
                        
                        // Make sure we append the proper extension for the preview URL
                        // Some AEM preview URLs require the file extension to be explicitly included, like .jpg
                        const fileExtension = asset.name.split('.').pop().toLowerCase();
                        
                        // Construct the preview URL with the extension
                        const previewUrl = `https://delivery-p108396-e1040009.adobeaemcloud.com/adobe/assets/${asset.id}/as/preview-${encodeURIComponent(asset.name)}.${fileExtension}?width=350&preferwebp=true`;
                        
                        console.log(`Loading preview image for ${asset.name}: ${previewUrl}`);
                        
                        previewHtml = `
                            <div class="mb-2 bg-gray-200 dark:bg-gray-800 rounded-md flex items-center justify-center overflow-hidden" style="height: 120px;">
                                <img src="${previewUrl}" alt="${asset.name}" class="object-contain max-h-full max-w-full" 
                                     onerror="this.onerror=null; this.src=''; console.log('Preview image failed to load for: ${asset.name}'); this.parentNode.innerHTML='<div class=\\'text-4xl\\'>${icon}</div>';">
                            </div>
                        `;
                    } else {
                        // Fallback to icon for images without proper ID
                        previewHtml = `
                            <div class="mb-2 bg-gray-200 dark:bg-gray-800 rounded-md flex items-center justify-center overflow-hidden" style="height: 120px;">
                                <div class="text-4xl">${icon}</div>
                            </div>
                        `;
                    }
                } else if (isVideo) {
                    // Video thumbnails could be handled similarly if we have preview URLs for them
                    previewHtml = `
                        <div class="mb-2 bg-gray-200 dark:bg-gray-800 rounded-md flex items-center justify-center overflow-hidden" style="height: 120px;">
                            <div class="text-4xl">${icon}</div>
                        </div>
                    `;
                } else {
                    // For other file types, show a smaller icon
                    previewHtml = `
                        <div class="mb-2 flex items-center">
                            <div class="text-2xl mr-2">${icon}</div>
                            <div class="text-xs bg-gray-200 dark:bg-gray-800 px-2 py-1 rounded uppercase">${asset.format || asset.type}</div>
                        </div>
                    `;
                }
                
                // Build the card content
                assetCard.innerHTML = `
                    ${previewHtml}
                    <div class="overflow-hidden">
                        <div class="font-medium truncate" title="${asset.name}">${asset.name}</div>
                        <div class="mt-1 flex flex-wrap gap-1">
                            ${asset.project ? `<span class="text-xs bg-primary/10 text-primary px-1.5 py-0.5 rounded-full">${asset.project}</span>` : ''}
                            ${asset.channel ? `<span class="text-xs bg-gray-200 dark:bg-gray-600 px-1.5 py-0.5 rounded-full">${asset.channel}</span>` : ''}
                        </div>
                        <div class="text-xs text-gray-500 dark:text-gray-400 mt-1">
                            <span title="Country-Language">${asset.countryLanguage || 'gl-en'}</span>
                            ${asset.variation ? ` ¬∑ ${asset.variation}` : ''}
                            ${asset.width && asset.height ? ` ¬∑ ${asset.width}√ó${asset.height}` : ''}
                        </div>
                    </div>
                `;
                
                assetsContainer.appendChild(assetCard);
            });
        }

        // Generate folder structure based on filtered assets
        function generateFolderStructure(assets) {
            const folderStructureContainer = document.getElementById('folder-structure');
            
            if (assets.length === 0) {
                folderStructureContainer.innerHTML = '<div class="text-gray-500 dark:text-gray-400">No assets to organize</div>';
                return;
            }
            
            // Get active collection for folder naming
            const activeCollection = CollectionManager.activeCollection;
            const collectionName = activeCollection ? activeCollection.name : "Collection";
            
            // Group assets by channel, countryLanguage, and variation
            // Use collection name as the "project" folder instead of asset.project
            const structure = {};
            
            // Create a single project entry using the collection name
            structure[collectionName] = {};
            
            assets.forEach(asset => {
                const { channel, countryLanguage, variation, name } = asset;
                
                if (!structure[collectionName][channel]) structure[collectionName][channel] = {};
                if (!structure[collectionName][channel][countryLanguage]) structure[collectionName][channel][countryLanguage] = {};
                if (!structure[collectionName][channel][countryLanguage][variation]) structure[collectionName][channel][countryLanguage][variation] = [];
                
                structure[collectionName][channel][countryLanguage][variation].push(name);
            });
            
            // Save the structure for sharing
            currentFolderStructure = structure;
            
            // Generate HTML representation of the folder structure
            let html = '';
            
            // Add base folder if Cloudflare is configured
            const config = CloudflareConfig.get() || CloudflareConfig.currentConfig;
            if (CloudflareConfig.isConfigured() && config.folder) {
                html += `<div class="mb-1">üìÅ <span class="font-semibold">${config.folder}</span></div>`;
            }
            
            // Loop through the structure
            Object.entries(structure).sort().forEach(([project, channels]) => {
                // Project/Collection level
                html += `<div class="${config && config.folder ? 'ml-4' : ''} mb-1">üìÅ <span class="font-semibold">${project}</span></div>`;
                
                Object.entries(channels).sort().forEach(([channel, countryLanguages]) => {
                    // Channel level
                    html += `<div class="${config && config.folder ? 'ml-8' : 'ml-4'} mb-1">üìÅ <span class="font-semibold">${channel}</span></div>`;
                    
                    Object.entries(countryLanguages).sort().forEach(([countryLanguage, variations]) => {
                        // Country-language level
                        html += `<div class="${config && config.folder ? 'ml-12' : 'ml-8'} mb-1">üìÅ <span class="font-semibold">${countryLanguage}</span></div>`;
                        
                        Object.entries(variations).sort().forEach(([variation, assetNames]) => {
                            // Variation level
                            html += `<div class="${config && config.folder ? 'ml-16' : 'ml-12'} mb-1">üìÅ <span class="font-semibold">${variation}</span></div>`;
                            
                            // Asset files
                            assetNames.sort().forEach(name => {
                                const icon = fileTypeIcons[getFileType(name)] || 'üìÑ';
                                html += `<div class="${config && config.folder ? 'ml-20' : 'ml-16'} mb-1">${icon} ${name}</div>`;
                            });
                        });
                    });
                });
            });
            
            folderStructureContainer.innerHTML = html;
        }

        // Convert folder structure to different formats for sharing
        function getFolderStructureForSharing(format) {
            if (!currentFolderStructure) return "No folder structure available.";
            
            const config = CloudflareConfig.get() || CloudflareConfig.currentConfig;
            const baseFolder = (config && config.folder) ? config.folder : '';
            
            switch(format) {
                case 'text':
                    return generatePlainTextStructure(currentFolderStructure, baseFolder);
                case 'markdown':
                    return generateMarkdownStructure(currentFolderStructure, baseFolder);
                case 'json':
                    return JSON.stringify(currentFolderStructure, null, 2);
                default:
                    return generatePlainTextStructure(currentFolderStructure, baseFolder);
            }
        }

        // Generate plain text representation of folder structure
        function generatePlainTextStructure(structure, baseFolder) {
            let result = '';
            
            if (baseFolder) {
                result += `${baseFolder}\n`;
            }
            
            // Loop through each level of the structure
            Object.entries(structure).sort().forEach(([project, channels]) => {
                result += `${baseFolder ? '‚îú‚îÄ‚îÄ ' : ''}${project}/\n`;
                
                const projectPrefix = baseFolder ? '‚îÇ   ' : '';
                
                Object.entries(channels).sort().forEach(([channel, countryLanguages], cIndex, cArray) => {
                    const isLastChannel = cIndex === cArray.length - 1;
                    result += `${projectPrefix}${isLastChannel ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ '}${channel}/\n`;
                    
                    const channelPrefix = projectPrefix + (isLastChannel ? '    ' : '‚îÇ   ');
                    
                    Object.entries(countryLanguages).sort().forEach(([countryLanguage, variations], clIndex, clArray) => {
                        const isLastCountryLang = clIndex === clArray.length - 1;
                        result += `${channelPrefix}${isLastCountryLang ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ '}${countryLanguage}/\n`;
                        
                        const countryLangPrefix = channelPrefix + (isLastCountryLang ? '    ' : '‚îÇ   ');
                        
                        Object.entries(variations).sort().forEach(([variation, assetNames], vIndex, vArray) => {
                            const isLastVariation = vIndex === vArray.length - 1;
                            result += `${countryLangPrefix}${isLastVariation ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ '}${variation}/\n`;
                            
                            const variationPrefix = countryLangPrefix + (isLastVariation ? '    ' : '‚îÇ   ');
                            
                            assetNames.sort().forEach((name, aIndex) => {
                                const isLastAsset = aIndex === assetNames.length - 1;
                                result += `${variationPrefix}${isLastAsset ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ '}${name}\n`;
                            });
                        });
                    });
                });
            });
            
            return result;
        }

        // Generate markdown representation of folder structure
        function generateMarkdownStructure(structure, baseFolder) {
            let result = '';
            
            if (baseFolder) {
                result += `# ${baseFolder}\n\n`;
            }
            
            // Loop through each level of the structure
            Object.entries(structure).sort().forEach(([project, channels]) => {
                result += `${baseFolder ? '- ' : '# '}**${project}/**\n`;
                
                Object.entries(channels).sort().forEach(([channel, countryLanguages]) => {
                    result += `${baseFolder ? '  - ' : '- '}**${channel}/**\n`;
                    
                    Object.entries(countryLanguages).sort().forEach(([countryLanguage, variations]) => {
                        result += `${baseFolder ? '    - ' : '  - '}**${countryLanguage}/**\n`;
                        
                        Object.entries(variations).sort().forEach(([variation, assetNames]) => {
                            result += `${baseFolder ? '      - ' : '    - '}**${variation}/**\n`;
                            
                            assetNames.sort().forEach(name => {
                                const icon = getFileTypeEmoji(name);
                                result += `${baseFolder ? '        - ' : '      - '}${icon} ${name}\n`;
                            });
                        });
                    });
                });
                
                result += '\n';
            });
            
            return result;
        }

        // Get file type based on file extension
        function getFileType(filename) {
            const extension = filename.split('.').pop().toLowerCase();
            
            const typeMap = {
                'pdf': 'document',
                'docx': 'document',
                'doc': 'document',
                'txt': 'document',
                'zip': 'archive',
                'rar': 'archive',
                'jpg': 'image',
                'jpeg': 'image',
                'png': 'image',
                'gif': 'image',
                'mp4': 'video',
                'mov': 'video',
                'avi': 'video',
                'mp3': 'audio',
                'wav': 'audio',
                'psd': 'design',
                'ai': 'design',
                'xd': 'design',
                'html': 'code',
                'css': 'code',
                'js': 'code'
            };
            
            return typeMap[extension] || 'document';
        }

        // Get file type emoji for markdown
        function getFileTypeEmoji(filename) {
            const type = getFileType(filename);
            return fileTypeIcons[type] || 'üìÑ';
        }

        // Update the UI based on the current filters
        function updateUI() {
            const filteredAssets = filterAssets();
            displayAssets(filteredAssets);
            generateFolderStructure(filteredAssets);
        }

        // Show share modal with folder structure
        function showShareModal() {
            const format = document.getElementById('share-format').value;
            const structureText = getFolderStructureForSharing(format);
            
            document.getElementById('share-content').value = structureText;
            document.getElementById('share-modal').classList.remove('hidden');
        }

        // Copy share content to clipboard
        function copyShareContentToClipboard() {
            const shareContent = document.getElementById('share-content');
            shareContent.select();
            
            try {
                document.execCommand('copy');
                
                // Show feedback
                const copyBtn = document.getElementById('copy-share-btn');
                const originalText = copyBtn.innerHTML;
                
                copyBtn.innerHTML = `
                    <span class="flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
                        </svg>
                        Copied!
                    </span>
                `;
                
                setTimeout(() => {
                    copyBtn.innerHTML = originalText;
                }, 2000);
            } catch (err) {
                console.error('Failed to copy text: ', err);
            }
        }

        // Show connection status in the config modal
        function showConnectionStatus(success, message) {
            const connectionStatus = document.getElementById('connection-status');
            const statusDiv = connectionStatus.querySelector('div');
            
            connectionStatus.classList.remove('hidden');
            statusDiv.textContent = message;
            
            if (success) {
                statusDiv.classList.remove('bg-red-100', 'text-red-800', 'dark:bg-red-900', 'dark:text-red-200');
                statusDiv.classList.add('bg-green-100', 'text-green-800', 'dark:bg-green-900', 'dark:text-green-200');
            } else {
                statusDiv.classList.remove('bg-green-100', 'text-green-800', 'dark:bg-green-900', 'dark:text-green-200');
                statusDiv.classList.add('bg-red-100', 'text-red-800', 'dark:bg-red-900', 'dark:text-red-200');
            }
        }

        // Show success message
        function showSuccess(message) {
            document.getElementById('success-message').textContent = message;
            document.getElementById('success-modal').classList.remove('hidden');
        }

        // Show error message
        function showError(message) {
            document.getElementById('error-message').textContent = message;
            document.getElementById('error-modal').classList.remove('hidden');
        }

        // Export assets to Cloudflare
        async function exportToCloudflare() {
            console.log("=== EXPORT TO CLOUDFLARE STARTED ===");
            
            // Show postfix input modal before proceeding
            document.getElementById('collection-postfix').value = '';
            document.getElementById('postfix-error').classList.add('hidden');
            
            // Update the collection prefix display and preview with the current collection name
            const activeCollection = CollectionManager.activeCollection;
            const collectionName = activeCollection ? activeCollection.name : "Collection";
            document.getElementById('collection-prefix').textContent = `${collectionName}_`;
            document.getElementById('final-name-preview').textContent = `${collectionName}_v1`;
            
            document.getElementById('export-postfix-modal').classList.remove('hidden');
            
            // Exit the current function - the actual export will be handled by the modal buttons
            return;
        }
        
        // Proceed with Cloudflare export after getting the postfix
        async function proceedWithExport(postfix) {
            console.log(`Proceeding with export with postfix: ${postfix}`);
            
            // Log the Cloudflare configuration status
            const cloudflareConfigStatus = CloudflareConfig.isConfigured();
            console.log(`Cloudflare Configuration Status: ${cloudflareConfigStatus ? 'Configured' : 'Not Configured (Demo Mode)'}`);
            
            if (cloudflareConfigStatus) {
                const config = CloudflareConfig.get() || CloudflareConfig.currentConfig;
                console.log(`Using Cloudflare Configuration:
                - API URL: ${config.url}
                - Base Folder: ${config.folder || '(root)'}`);
            }
            
            // SIMPLIFY: Use the currently displayed assets that match our folder structure
            // This directly uses what's shown in the UI, which matches the folder structure
            
            // Get the current folder structure info
            if (!currentFolderStructure) {
                console.error("ERROR: No folder structure available");
                showError('No folder structure available. Please apply filters first.');
                return;
            }
            
            // Extract the actual assets from the folder structure
            // This ensures we're using exactly what's used to generate the structure
            let assetsToExport = [];
            
            try {
                // First try to get assets directly from the asset panels
                const assetContainer = document.getElementById('assets-container');
                if (assetContainer) {
                    // Count displayed assets to verify we have something
                    const assetCards = assetContainer.querySelectorAll('.bg-gray-50, .dark\\:bg-gray-700');
                    console.log(`Found ${assetCards.length} asset cards in the UI`);
                }
                
                // Get the actual assets that match our filters
                const activeCollection = CollectionManager.activeCollection;
                console.log(`Active Collection: ${activeCollection ? activeCollection.name : 'None'}`);
                
                // IMPORTANT: Get a fresh set of filtered assets to ensure we have the latest
                assetsToExport = filterAssets();
                console.log(`Fresh filter returned ${assetsToExport.length} assets`);
                
                // Fall back to currentCollectionAssets if filter returns nothing
                if (assetsToExport.length === 0 && CollectionManager.currentCollectionAssets.length > 0) {
                    console.log("Using currentCollectionAssets as fallback");
                    assetsToExport = CollectionManager.currentCollectionAssets;
                }
                
                // Try another fallback for demo assets
                if (assetsToExport.length === 0 && CollectionManager.currentFilteredDemoAssets && 
                    CollectionManager.currentFilteredDemoAssets.length > 0) {
                    console.log("Using currentFilteredDemoAssets as fallback");
                    assetsToExport = CollectionManager.currentFilteredDemoAssets;
                }
                
                // Last resort: If we have a collection but no assets, try a more generic filter
                if (assetsToExport.length === 0 && activeCollection) {
                    console.log("Attempting to get all assets from current collection");
                    
                    // For API collections
                    if (activeCollection.collectionId) {
                        try {
                            const result = await CollectionManager.searchCollectionAssets(
                                activeCollection.collectionId,
                                {} // Empty filter to get all assets
                            );
                            assetsToExport = result.assets;
                            console.log(`Retrieved ${assetsToExport.length} assets from collection without filters`);
                        } catch (err) {
                            console.error("Failed to get collection assets:", err);
                        }
                    } 
                    // For demo collections
                    else if (activeCollection.filters && activeCollection.filters.project) {
                        const project = activeCollection.filters.project;
                        assetsToExport = contentHubAssets.filter(asset => 
                            asset.project === project
                        );
                        console.log(`Retrieved ${assetsToExport.length} demo assets for project ${project}`);
                    }
                }
            } catch (error) {
                console.error("Error preparing assets for export:", error);
                // Continue with whatever assets we have, the zero-check below will catch if there are none
            }
            
            console.log(`Final assets to export: ${assetsToExport.length}`);
            
            // Log some details about the assets being exported
            if (assetsToExport.length > 0) {
                // Count by type
                const typeCount = {};
                assetsToExport.forEach(asset => {
                    typeCount[asset.type] = (typeCount[asset.type] || 0) + 1;
                });
                
                console.log("Asset types breakdown:");
                Object.entries(typeCount).forEach(([type, count]) => {
                    console.log(`- ${type}: ${count}`);
                });
                
                // Sample of asset names (up to 5)
                const sampleAssets = assetsToExport.slice(0, 5).map(a => a.name);
                console.log(`Sample assets: ${sampleAssets.join(', ')}${assetsToExport.length > 5 ? '...' : ''}`);
            }
            
            if (assetsToExport.length === 0) {
                console.error("ERROR: No assets to export");
                showError('No assets to export. Please adjust your filters and try again or reload the page.');
                return;
            }
            
            // If Cloudflare is not configured, show demo success message
            if (!CloudflareConfig.isConfigured()) {
                console.log("Running in demo mode - showing success message without actual export");
                // Show share button after export (even in demo mode)
                document.getElementById('share-btn').classList.remove('hidden');
                
                document.getElementById('success-message').textContent = "The assets have been organized according to the specified structure (Demo Mode).";
                document.getElementById('success-modal').classList.remove('hidden');
                return;
            }
            
            // Show export progress modal
            const exportModal = document.getElementById('export-modal');
            const progressBar = document.getElementById('export-progress-bar');
            const percentageText = document.getElementById('export-percentage');
            const statusText = document.getElementById('export-status');
            
            // Reset progress display
            progressBar.style.width = '0%';
            percentageText.textContent = '0%';
            statusText.textContent = 'Preparing to export assets...';
            
            exportModal.classList.remove('hidden');
            
            try {
                console.log("Starting actual export process");
                
                // Get Cloudflare service instance
                const cloudflareService = getCloudflareService();
                console.log("CloudflareService instance created");
                
                // Set up progress tracking
                let lastStatus = "";
                let lastPercentage = 0;
                
                // Modify the collection name if postfix was provided
                if (postfix && postfix.length > 0) {
                    const activeCollection = CollectionManager.activeCollection;
                    if (activeCollection) {
                        // Make a copy of the active collection with the modified name
                        const modifiedCollection = { ...activeCollection };
                        modifiedCollection.name = `${activeCollection.name}_${postfix}`;
                        
                        // Temporarily replace the active collection
                        const originalCollection = CollectionManager.activeCollection;
                        CollectionManager.activeCollection = modifiedCollection;
                        
                        // Log the change
                        console.log(`Collection name modified for export: ${originalCollection.name} -> ${modifiedCollection.name}`);
                    }
                }
                
                // Call export method with the assets we prepared in assetsToExport
                await cloudflareService.exportAssets(assetsToExport, (percentage, status) => {
                    // Update UI
                    progressBar.style.width = `${percentage}%`;
                    percentageText.textContent = `${Math.round(percentage)}%`;
                    statusText.textContent = status;
                    
                    // Auto-scroll status to bottom
                    statusText.scrollTop = statusText.scrollHeight;
                    
                    // Only log when status changes or percentage changes significantly
                    if (status !== lastStatus || Math.abs(percentage - lastPercentage) >= 5) {
                        console.log(`Export progress ${Math.round(percentage)}%: ${status}`);
                        lastStatus = status;
                        lastPercentage = percentage;
                    }
                });
                
                console.log("Export completed successfully");
                
                // Hide export modal after successful export
                exportModal.classList.add('hidden');
                
                // Generate and set read-only view link before showing success message
                updateReadOnlyViewLink();
                
                // Show success message
                showSuccess("The assets have been successfully exported to Cloudflare R2.");
                console.log("=== EXPORT TO CLOUDFLARE COMPLETED ===");
            } catch (error) {
                console.error('Export to Cloudflare failed:', error);
                
                // Add more detailed error logging
                if (error.stack) {
                    console.error('Error stack:', error.stack);
                }
                
                // Hide export modal
                exportModal.classList.add('hidden');
                
                // Show error message
                showError(`Export to Cloudflare failed: ${error.message}`);
                console.log("=== EXPORT TO CLOUDFLARE FAILED ===");
            }
        }

        // Initialize the configuration form with saved data
        function initConfigForm() {
            const config = CloudflareConfig.get();
            if (config) {
                document.getElementById('api-url').value = config.url || '';
                document.getElementById('api-key').value = config.apiKey || '';
                document.getElementById('base-folder').value = config.folder || '';
                document.getElementById('remember-config').checked = true;
            }
            
            // Initialize Adobe AEM config
            const aemConfig = AEMConfig.get();
            if (aemConfig) {
                document.getElementById('aem-endpoint').value = aemConfig.endpoint || '';
                document.getElementById('aem-path').value = aemConfig.path || '/content/dam/assets';
                
                // Set the CORS proxy toggle based on saved config
                const corsToggle = document.getElementById('use-cors-proxy');
                if (corsToggle && typeof aemConfig.useCorsProxy !== 'undefined') {
                    corsToggle.checked = aemConfig.useCorsProxy;
                }
            }
        }

        // Get configuration from form
        function getConfigFromForm() {
            return {
                url: document.getElementById('api-url').value.trim(),
                apiKey: document.getElementById('api-key').value.trim(),
                folder: document.getElementById('base-folder').value.trim()
            };
        }

        // Get AEM configuration from form
        function getAemConfigFromForm() {
            return {
                endpoint: document.getElementById('aem-endpoint').value.trim(),
                path: document.getElementById('aem-path').value.trim()
            };
        }

        // Load assets
        async function loadAssets() {
            try {
                if (CloudflareConfig.isConfigured()) {
                    // In a real implementation, this would load assets from content hub via listing API
                    // For now, we'll use the same mock data
                    populateFilterDropdowns();
                    updateUI();
                } else {
                    // Use mock data
                    populateFilterDropdowns();
                    updateUI();
                }
            } catch (error) {
                console.error('Error loading assets:', error);
                showError(`Failed to load assets: ${error.message}`);
            }
        }

        // Initialize the application
        async function init() {
            // Check if we should use default Cloudflare configuration
            const config = CloudflareConfig.get();
            
            if (config) {
                // Use saved config if it exists
                CloudflareConfig.currentConfig = config;
            } else {
                // Use default config if no saved config exists
                CloudflareConfig.currentConfig = CloudflareConfig.getDefault();
                
                // Auto-save the default config (not remembering it in localStorage)
                CloudflareConfig.save(CloudflareConfig.getDefault(), false);
                
                // Show a notification that we're using default settings
                setTimeout(() => {
                    showNotification('Using default Cloudflare configuration. You can adjust settings from the Settings menu.', 'info', 7000);
                }, 1500);
            }
            
            // Prepopulate the settings form with the default values for the next time it's opened
            document.getElementById('api-url').value = DEFAULT_CONFIG.url;
            document.getElementById('api-key').value = DEFAULT_CONFIG.apiKey;
            document.getElementById('base-folder').value = DEFAULT_CONFIG.folder;
            
            // Update mode indicator
            updateModeIndicator();
            
            // Check for existing authentication token and update UI accordingly
            const imsToken = document.getElementById('imsToken').value;
            if (imsToken) {
                // User is already authenticated
                updateAuthStatusUI(true);
                
                // Update sign in button to show signed in state
                const signInBtn = document.getElementById('signInBtn');
                signInBtn.innerHTML = '<i class="fas fa-check-circle mr-2"></i>Signed In';
                signInBtn.classList.remove('bg-primary', 'hover:bg-secondary');
                signInBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            }
            
            // Load assets
            loadAssets();
            
            // Show loading state for collections
            const collectionsList = document.getElementById('collections-list-welcome');
            collectionsList.innerHTML = '<li class="text-center p-4"><div class="inline-block animate-spin rounded-full h-8 w-8 border-4 border-primary/30 border-t-primary"></div><div class="mt-2">Loading collections...</div></li>';
            
            try {
                // Load and display collections in the welcome screen
                const collections = await CollectionManager.getAllCollections();
                
                // Cache the collections in memory
                CollectionManager.cacheCollections(collections);
                
                // Populate the UI with collections
                populateWelcomeCollectionsList(collections);
            } catch (error) {
                console.error('Error loading initial collections:', error);
                collectionsList.innerHTML = '<li class="text-red-500 dark:text-red-400 p-4 text-center">Error loading collections. Please try again.</li>';
            }
            
            // Set up collections search box in welcome screen with debounce
            const welcomeSearchBox = document.getElementById('collection-search-welcome');
            let searchTimeout = null;
            
            welcomeSearchBox.addEventListener('input', (e) => {
                // Clear previous timeout
                if (searchTimeout) {
                    clearTimeout(searchTimeout);
                }
                
                // Show loading indicator
                collectionsList.innerHTML = '<li class="text-center p-4"><div class="inline-block animate-spin rounded-full h-8 w-8 border-4 border-primary/30 border-t-primary"></div><div class="mt-2">Searching...</div></li>';
                
                // Set new timeout to avoid making too many requests while typing
                searchTimeout = setTimeout(async () => {
                    const query = e.target.value.trim();
                    try {
                        const searchResults = await CollectionManager.searchCollections(query);
                        // Update the cache with these search results
                        CollectionManager.cacheCollections(searchResults);
                        // Populate the UI
                        populateWelcomeCollectionsList(searchResults);
                    } catch (error) {
                        console.error('Error searching collections:', error);
                        collectionsList.innerHTML = '<li class="text-red-500 dark:text-red-400 p-4 text-center">Error searching collections. Please try again.</li>';
                    }
                }, 500); // 500ms debounce time
            });
            
            // Set up back to collections button
            document.getElementById('back-to-collections-btn').addEventListener('click', async () => {
                clearCollectionSelection();
                
                // Show loading state for collections
                const collectionsList = document.getElementById('collections-list-welcome');
                collectionsList.innerHTML = '<li class="text-center p-4"><div class="inline-block animate-spin rounded-full h-8 w-8 border-4 border-primary/30 border-t-primary"></div><div class="mt-2">Loading collections...</div></li>';
                
                try {
                    // Check if there's a search term in the search box
                    const searchBox = document.getElementById('collection-search-welcome');
                    const searchTerm = searchBox.value.trim();
                    
                    // Reload collections list with the current search term if any
                    let collections;
                    if (searchTerm) {
                        collections = await CollectionManager.searchCollections(searchTerm);
                    } else {
                        collections = await CollectionManager.getAllCollections();
                    }
                    
                    // Update the cache with these results
                    CollectionManager.cacheCollections(collections);
                    
                    // Populate the UI with the updated collections
                    populateWelcomeCollectionsList(collections);
                } catch (error) {
                    console.error('Error loading collections:', error);
                    const collectionsList = document.getElementById('collections-list-welcome');
                    collectionsList.innerHTML = '<li class="text-red-500 dark:text-red-400 p-4 text-center">Error loading collections. Please try again.</li>';
                    
                    // Show notification about the error
                    showNotification('Failed to load collections: ' + error.message, 'error');
                }
            });
            
            // Set up the Sign In button
            document.getElementById('signInBtn').addEventListener('click', () => {
                loginWithIMS();
            });
            
            // Remove share button event listeners since the button is no longer present
            
            // Note: The share modal elements have been removed from the DOM
            // We should not attempt to add event listeners to these elements
            // Commenting out instead of adding null checks for clarity

            /* 
            // These elements don't exist anymore:
            
            // Share format change
            // const shareFormat = document.getElementById('share-format');
            // if (shareFormat) {
            //     shareFormat.addEventListener('change', () => {...});
            // }
            
            // Copy to clipboard button
            // const copyShareBtn = document.getElementById('copy-share-btn');
            // if (copyShareBtn) {
            //     copyShareBtn.addEventListener('click', copyShareContentToClipboard);
            // }
            
            // Close share modal buttons
            // const closeShareModal = document.getElementById('close-share-modal');
            // if (closeShareModal) {
            //     closeShareModal.addEventListener('click', () => {...});
            // }
            
            // const closeShareBtn = document.getElementById('close-share-btn');
            // if (closeShareBtn) {
            //     closeShareBtn.addEventListener('click', () => {...});
            // }
            */
            
            // Set up tab functionality in settings modal
            document.querySelectorAll('.tab-btn').forEach(button => {
                button.addEventListener('click', () => {
                    // Deactivate all tabs
                    document.querySelectorAll('.tab-btn').forEach(btn => {
                        btn.classList.remove('border-primary', 'text-primary');
                        btn.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
                    });
                    
                    // Hide all tab content
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.add('hidden');
                    });
                    
                    // Activate clicked tab
                    button.classList.remove('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
                    button.classList.add('border-primary', 'text-primary');
                    
                    // Show corresponding tab content
                    const tabId = button.id.replace('tab-btn-', '');
                    document.getElementById(`tab-content-${tabId}`).classList.remove('hidden');
                });
            });
            
            // Set up event listeners for filters
            document.getElementById('apply-filters').addEventListener('click', async () => {
                try {
                    console.log("Apply filters button clicked");
                    
                    // Show loading indicator
                    const assetsContainer = document.getElementById('assets-container');
                    const assetsCount = document.getElementById('assets-count');
                    const folderStructureContainer = document.getElementById('folder-structure');
                    
                    assetsContainer.innerHTML = '<div class="col-span-full flex flex-col items-center justify-center py-8"><div class="animate-spin rounded-full h-10 w-10 border-4 border-primary/30 border-t-primary mb-4"></div><div>Updating assets...</div></div>';
                    assetsCount.textContent = 'Loading...';
                    folderStructureContainer.innerHTML = '<div class="text-center py-4"><div class="inline-block animate-spin rounded-full h-6 w-6 border-4 border-primary/30 border-t-primary mb-2"></div><div>Updating folder structure...</div></div>';
                    
                    // Get collection ID and current filters
                    const activeCollection = CollectionManager.activeCollection;
                    let filteredAssets = [];
                    
                    if (activeCollection && activeCollection.collectionId) {
                        // Real API collection - get filter values
                        const filters = {
                            channel: document.getElementById('channel').value || '',
                            country: document.getElementById('country').value || '',
                            language: document.getElementById('language').value || '',
                            variation: document.getElementById('variation').value || ''
                        };
                        
                        console.log('Applying filters:', filters);
                        
                        // Fetch assets with these filters
                        const result = await CollectionManager.searchCollectionAssets(
                            activeCollection.collectionId,
                            filters
                        );
                        
                        // Update the filter panel with new facets while preserving selected values
                        CollectionManager.updateFiltersFromFacets(result.facets, filters);
                        
                        // *IMPORTANT* Store the filtered results in the currentCollectionAssets to ensure
                        // they can be exported properly later
                        filteredAssets = result.assets;
                        CollectionManager.currentCollectionAssets = filteredAssets;
                        console.log(`Fetched ${filteredAssets.length} assets from API with filters`);
                    } else {
                        console.log('Using demo mode filtering');
                        // Demo data - use local filtering
                        filteredAssets = filterAssets();
                        console.log('filteredAssets:', filteredAssets);
                        
                        // Store the filtered assets for export later
                        CollectionManager.currentFilteredDemoAssets = filteredAssets;
                        console.log(`Filtered demo assets: ${filteredAssets.length} assets`);
                    }
                    
                    // Update the UI with filtered assets
                    displayAssets(filteredAssets);
                    generateFolderStructure(filteredAssets);
                    
                    // Log the folder structure for debugging
                    console.log('Updated folder structure:', currentFolderStructure);
                    
                    // Show a notification about the filtering result
                    if (filteredAssets.length === 0) {
                        showNotification('No assets match the selected filters. Try adjusting your criteria.', 'warning');
                    } else {
                        showNotification(`Found ${filteredAssets.length} assets matching your filters`, 'success', 3000);
                    }
                } catch (error) {
                    console.error('Error applying filters:', error);
                    showNotification('Error applying filters: ' + error.message, 'error');
                    
                    // Show error in assets container
                    const assetsContainer = document.getElementById('assets-container');
                    const assetsCount = document.getElementById('assets-count');
                    assetsContainer.innerHTML = '<div class="col-span-full text-center text-red-500 dark:text-red-400 py-4">Error applying filters. Please try again.</div>';
                    assetsCount.textContent = 'Error';
                }
            });
            
            document.getElementById('clear-filters').addEventListener('click', async () => {
                document.getElementById('channel').value = '';
                document.getElementById('country').value = '';
                document.getElementById('language').value = '';
                document.getElementById('variation').value = '';
                
                try {
                    // Show loading indicator
                    const assetsContainer = document.getElementById('assets-container');
                    const assetsCount = document.getElementById('assets-count');
                    assetsContainer.innerHTML = '<div class="col-span-full flex flex-col items-center justify-center py-8"><div class="animate-spin rounded-full h-10 w-10 border-4 border-primary/30 border-t-primary mb-4"></div><div>Clearing filters...</div></div>';
                    assetsCount.textContent = 'Loading...';
                    
                    // Get active collection
                    const activeCollection = CollectionManager.activeCollection;
                    
                    if (activeCollection && activeCollection.collectionId) {
                        // Reload assets with no filters
                        const result = await CollectionManager.searchCollectionAssets(
                            activeCollection.collectionId
                        );
                        
                        // Update the filter dropdowns with fresh facets and no selections
                        CollectionManager.populateFiltersFromFacets(result.facets);
                        
                        // Update the UI with all assets
                        displayAssets(result.assets);
                        generateFolderStructure(result.assets);
                    } else {
                        // Demo data - use local filtering
                        updateUI();
                    }
                } catch (error) {
                    console.error('Error clearing filters:', error);
                    showNotification('Error clearing filters: ' + error.message, 'error');
                    
                    // Show error in assets container
                    updateUI(); // Attempt to restore the view anyway
                }
            });
            
            // Set up event listeners for export button
            document.getElementById('export-btn').addEventListener('click', exportToCloudflare);
            
            // Set up event listeners for the read-only view functionality
            document.getElementById('copy-readonly-link').addEventListener('click', copyReadOnlyViewLink);
            document.getElementById('view-readonly-btn').addEventListener('click', openReadOnlyViewer);
            
            // Set up event listeners for config button
            document.getElementById('config-btn').addEventListener('click', () => {
                initConfigForm();
                document.getElementById('connection-status').classList.add('hidden');
                document.getElementById('config-modal').classList.remove('hidden');
            });
            
            document.getElementById('close-config-modal').addEventListener('click', () => {
                document.getElementById('config-modal').classList.add('hidden');
            });
            
            document.getElementById('test-connection-btn').addEventListener('click', async () => {
                const config = getConfigFromForm();
                
                if (!config.url || !config.apiKey) {
                    showConnectionStatus(false, "API URL and API Key are required");
                    return;
                }
                
                // Test the connection
                const cloudflareService = new CloudflareService(config);
                const result = await cloudflareService.testConnection();
                showConnectionStatus(result.success, result.message);
            });
            
            document.getElementById('save-config-btn').addEventListener('click', () => {
                const config = getConfigFromForm();
                const remember = document.getElementById('remember-config').checked;
                
                // Validate required fields
                if (!config.url || !config.apiKey) {
                    showConnectionStatus(false, "API URL and API Key are required");
                    return;
                }
                
                // Save the configuration
                CloudflareConfig.save(config, remember);
                
                // Close the modal
                document.getElementById('config-modal').classList.add('hidden');
                
                // Reload assets based on the new configuration
                loadAssets();
            });
            
            document.getElementById('clear-config-btn').addEventListener('click', () => {
                document.getElementById('api-url').value = '';
                document.getElementById('api-key').value = '';
                document.getElementById('base-folder').value = '';
                document.getElementById('remember-config').checked = false;
                
                // Clear the configuration
                CloudflareConfig.clear();
                
                // Hide the connection status
                document.getElementById('connection-status').classList.add('hidden');
            });
            
            // Save Adobe AEM configuration
            document.getElementById('save-adobe-config-btn').addEventListener('click', () => {
                const config = getAemConfigFromForm();
                
                // Add the CORS proxy setting to the config
                const useCorsProxy = document.getElementById('use-cors-proxy').checked;
                config.useCorsProxy = useCorsProxy;
                
                // Save the configuration
                AEMConfig.save(config);
                
                // Close the modal
                document.getElementById('config-modal').classList.add('hidden');
                
                // Show success notification
                showNotification(`Adobe config saved (CORS Proxy: ${useCorsProxy ? 'Enabled' : 'Disabled'})`, 'success');
            });
            
            // Cancel export button
            document.getElementById('cancel-export-btn').addEventListener('click', () => {
                document.getElementById('export-modal').classList.add('hidden');
                // In a real implementation, you would need to abort the export process
            });
            
            // Close success modal
            document.getElementById('close-success-modal').addEventListener('click', () => {
                document.getElementById('success-modal').classList.add('hidden');
            });
            
            // Close error modal
            document.getElementById('close-error-modal').addEventListener('click', () => {
                document.getElementById('error-modal').classList.add('hidden');
            });

            // Check if we have an IMS token from a redirect
            handleImsRedirect();
        }
        
        // Run initialization when DOM is ready
        document.addEventListener('DOMContentLoaded', init);

// Direct function to open the settings modal
function openSettingsModal() {
    console.log("üìã Settings button clicked directly via onclick");
    initConfigForm();
    document.getElementById('connection-status').classList.add('hidden');
    document.getElementById('config-modal').classList.remove('hidden');
}

// Direct function to close the settings modal
function closeSettingsModal() {
    console.log("üìã Close settings button clicked directly via onclick");
    document.getElementById('config-modal').classList.add('hidden');
}

// Function to switch between settings tabs
function switchSettingsTab(tabId) {
    console.log(`üìã Switching to settings tab: ${tabId}`);
    
    // Deactivate all tabs
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('border-primary', 'text-primary');
        btn.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
    });
    
    // Hide all tab content
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.add('hidden');
    });
    
    // Activate clicked tab
    const selectedTabBtn = document.getElementById(`tab-btn-${tabId}`);
    if (selectedTabBtn) {
        selectedTabBtn.classList.remove('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
        selectedTabBtn.classList.add('border-primary', 'text-primary');
    }
    
    // Show corresponding tab content
    const selectedTabContent = document.getElementById(`tab-content-${tabId}`);
    if (selectedTabContent) {
        selectedTabContent.classList.remove('hidden');
    }
}

// Test connection function for the settings panel
function testConnection() {
    const config = getConfigFromForm();
    
    if (!config.url || !config.apiKey) {
        showConnectionStatus(false, "API URL and API Key are required");
        return;
    }
    
    // Test the connection
    const cloudflareService = new CloudflareService(config);
    cloudflareService.testConnection().then(result => {
        showConnectionStatus(result.success, result.message);
    }).catch(error => {
        showConnectionStatus(false, "Connection test failed: " + error.message);
    });
}

// Save configuration function for the settings panel
function saveConfig() {
    const config = getConfigFromForm();
    const remember = document.getElementById('remember-config').checked;
    
    // Validate required fields
    if (!config.url || !config.apiKey) {
        showConnectionStatus(false, "API URL and API Key are required");
        return;
    }
    
    // Save the configuration
    CloudflareConfig.save(config, remember);
    
    // Close the modal
    document.getElementById('config-modal').classList.add('hidden');
    
    // Reload assets based on the new configuration
    loadAssets();
}

// Clear configuration function for the settings panel
function clearConfig() {
    document.getElementById('api-url').value = '';
    document.getElementById('api-key').value = '';
    document.getElementById('base-folder').value = '';
    document.getElementById('remember-config').checked = false;
    
    // Clear the configuration
    CloudflareConfig.clear();
    
    // Hide the connection status
    document.getElementById('connection-status').classList.add('hidden');
}

// Save Adobe configuration function for the settings panel
function saveAdobeConfig() {
    const config = getAemConfigFromForm();
    
    // Add the CORS proxy setting to the config
    const useCorsProxy = document.getElementById('use-cors-proxy').checked;
    config.useCorsProxy = useCorsProxy;
    
    // Save the configuration
    AEMConfig.save(config);
    
    // Close the modal
    document.getElementById('config-modal').classList.add('hidden');
    
    // Show success notification
    showNotification(`Adobe config saved (CORS Proxy: ${useCorsProxy ? 'Enabled' : 'Disabled'})`, 'success');
}

// Force reattachment of all essential event listeners
function reattachAllEventListeners() {
    console.log("üõ†Ô∏è Reattaching ALL event listeners");
    
    try {
        // Settings button
        const configBtn = document.getElementById('config-btn');
        if (configBtn) {
            console.log("Reattaching Settings button");
            configBtn.addEventListener('click', () => {
                initConfigForm();
                document.getElementById('connection-status').classList.add('hidden');
                document.getElementById('config-modal').classList.remove('hidden');
            });
        }
        
        // Apply Filters button
        const applyFiltersBtn = document.getElementById('apply-filters');
        if (applyFiltersBtn) {
            console.log("Reattaching Apply Filters button");
            applyFiltersBtn.addEventListener('click', async () => {
                console.log("Apply filters clicked!");
                try {
                    // Show loading indicator
                    const assetsContainer = document.getElementById('assets-container');
                    const assetsCount = document.getElementById('assets-count');
                    const folderStructureContainer = document.getElementById('folder-structure');
                    
                    if (assetsContainer) assetsContainer.innerHTML = '<div class="col-span-full flex flex-col items-center justify-center py-8"><div class="animate-spin rounded-full h-10 w-10 border-4 border-primary/30 border-t-primary mb-4"></div><div>Updating assets...</div></div>';
                    if (assetsCount) assetsCount.textContent = 'Loading...';
                    if (folderStructureContainer) folderStructureContainer.innerHTML = '<div class="text-center py-4"><div class="inline-block animate-spin rounded-full h-6 w-6 border-4 border-primary/30 border-t-primary mb-2"></div><div>Updating folder structure...</div></div>';
                    
                    // Get fresh filtered assets
                    const filteredAssets = filterAssets();
                    console.log(`Filtered ${filteredAssets.length} assets`);
                    
                    // Update the UI with filtered assets
                    displayAssets(filteredAssets);
                    generateFolderStructure(filteredAssets);
                    
                    // Show notification about result
                    if (filteredAssets.length === 0) {
                        showNotification('No assets match the selected filters. Try adjusting your criteria.', 'warning');
                    } else {
                        showNotification(`Found ${filteredAssets.length} assets matching your filters`, 'success', 3000);
                    }
                } catch (error) {
                    console.error('Error applying filters:', error);
                    showNotification('Error applying filters: ' + error.message, 'error');
                }
            });
        }
        
        // Export to Cloudflare button
        const exportBtn = document.getElementById('export-btn');
        if (exportBtn) {
            console.log("Reattaching Export to Cloudflare button");
            exportBtn.addEventListener('click', () => {
                console.log("Export button clicked!");
                exportToCloudflare();
            });
        }
        
        // Sign in button
        const signInBtn = document.getElementById('signInBtn');
        if (signInBtn) {
            console.log("Reattaching Sign In button");
            signInBtn.addEventListener('click', () => {
                loginWithIMS();
            });
        }
        
        // Back to collections button
        const backToCollectionsBtn = document.getElementById('back-to-collections-btn');
        if (backToCollectionsBtn) {
            console.log("Reattaching Back to Collections button");
            backToCollectionsBtn.addEventListener('click', async () => {
                clearCollectionSelection();
                
                // Show loading state for collections
                const collectionsList = document.getElementById('collections-list-welcome');
                if (collectionsList) {
                    collectionsList.innerHTML = '<li class="text-center p-4"><div class="inline-block animate-spin rounded-full h-8 w-8 border-4 border-primary/30 border-t-primary"></div><div class="mt-2">Loading collections...</div></li>';
                }
                
                try {
                    // Check if there's a search term in the search box
                    const searchBox = document.getElementById('collection-search-welcome');
                    const searchTerm = searchBox ? searchBox.value.trim() : '';
                    
                    // Reload collections list with the current search term if any
                    let collections;
                    if (searchTerm) {
                        collections = await CollectionManager.searchCollections(searchTerm);
                    } else {
                        collections = await CollectionManager.getAllCollections();
                    }
                    
                    // Update the cache with these results
                    CollectionManager.cacheCollections(collections);
                    
                    // Populate the UI with the updated collections
                    populateWelcomeCollectionsList(collections);
                } catch (error) {
                    console.error('Error loading collections:', error);
                    if (collectionsList) {
                        collectionsList.innerHTML = '<li class="text-red-500 dark:text-red-400 p-4 text-center">Error loading collections. Please try again.</li>';
                    }
                    
                    // Show notification about the error
                    showNotification('Failed to load collections: ' + error.message, 'error');
                }
            });
        }
        
        // Clear filters button
        const clearFiltersBtn = document.getElementById('clear-filters');
        if (clearFiltersBtn) {
            console.log("Reattaching Clear Filters button");
            clearFiltersBtn.addEventListener('click', async () => {
                const channelSelect = document.getElementById('channel');
                const countrySelect = document.getElementById('country');
                const languageSelect = document.getElementById('language');
                const variationSelect = document.getElementById('variation');
                
                if (channelSelect) channelSelect.value = '';
                if (countrySelect) countrySelect.value = '';
                if (languageSelect) languageSelect.value = '';
                if (variationSelect) variationSelect.value = '';
                
                try {
                    // Show loading indicator
                    const assetsContainer = document.getElementById('assets-container');
                    const assetsCount = document.getElementById('assets-count');
                    if (assetsContainer) {
                        assetsContainer.innerHTML = '<div class="col-span-full flex flex-col items-center justify-center py-8"><div class="animate-spin rounded-full h-10 w-10 border-4 border-primary/30 border-t-primary mb-4"></div><div>Clearing filters...</div></div>';
                    }
                    if (assetsCount) assetsCount.textContent = 'Loading...';
                    
                    // Get active collection
                    const activeCollection = CollectionManager.activeCollection;
                    
                    if (activeCollection && activeCollection.collectionId) {
                        // Reload assets with no filters
                        const result = await CollectionManager.searchCollectionAssets(
                            activeCollection.collectionId
                        );
                        
                        // Update the filter dropdowns with fresh facets and no selections
                        CollectionManager.populateFiltersFromFacets(result.facets);
                        
                        // Update the UI with all assets
                        displayAssets(result.assets);
                        generateFolderStructure(result.assets);
                    } else {
                        // Demo data - use local filtering
                        updateUI();
                    }
                } catch (error) {
                    console.error('Error clearing filters:', error);
                    showNotification('Error clearing filters: ' + error.message, 'error');
                    
                    // Attempt to restore the view anyway
                    updateUI(); 
                }
            });
        }
        
        // Modal related buttons
        // Close config modal button
        const closeConfigModalBtn = document.getElementById('close-config-modal');
        if (closeConfigModalBtn) {
            closeConfigModalBtn.addEventListener('click', () => {
                document.getElementById('config-modal').classList.add('hidden');
            });
        }
        
        // Test connection button
        const testConnectionBtn = document.getElementById('test-connection-btn');
        if (testConnectionBtn) {
            testConnectionBtn.addEventListener('click', async () => {
                const config = getConfigFromForm();
                
                if (!config.url || !config.apiKey) {
                    showConnectionStatus(false, "API URL and API Key are required");
                    return;
                }
                
                // Test the connection
                const cloudflareService = new CloudflareService(config);
                const result = await cloudflareService.testConnection();
                showConnectionStatus(result.success, result.message);
            });
        }
        
        // Save config button
        const saveConfigBtn = document.getElementById('save-config-btn');
        if (saveConfigBtn) {
            saveConfigBtn.addEventListener('click', () => {
                const config = getConfigFromForm();
                const rememberCheckbox = document.getElementById('remember-config');
                const remember = rememberCheckbox ? rememberCheckbox.checked : false;
                
                // Validate required fields
                if (!config.url || !config.apiKey) {
                    showConnectionStatus(false, "API URL and API Key are required");
                    return;
                }
                
                // Save the configuration
                CloudflareConfig.save(config, remember);
                
                // Close the modal
                const configModal = document.getElementById('config-modal');
                if (configModal) configModal.classList.add('hidden');
                
                // Reload assets based on the new configuration
                loadAssets();
            });
        }

        // Clear config button
        const clearConfigBtn = document.getElementById('clear-config-btn');
        if (clearConfigBtn) {
            clearConfigBtn.addEventListener('click', () => {
                const apiUrlInput = document.getElementById('api-url');
                const apiKeyInput = document.getElementById('api-key');
                const baseFolderInput = document.getElementById('base-folder');
                const rememberCheckbox = document.getElementById('remember-config');
                
                if (apiUrlInput) apiUrlInput.value = '';
                if (apiKeyInput) apiKeyInput.value = '';
                if (baseFolderInput) baseFolderInput.value = '';
                if (rememberCheckbox) rememberCheckbox.checked = false;
                
                // Clear the configuration
                CloudflareConfig.clear();
                
                // Hide the connection status
                const connectionStatus = document.getElementById('connection-status');
                if (connectionStatus) connectionStatus.classList.add('hidden');
            });
        }
        
        console.log("‚úÖ All event listeners reattached successfully");
    } catch (error) {
        console.error("‚ùå Error reattaching event listeners:", error);
    }
}

// Execute event listener reattachment if the page is already loaded
if (document.readyState === 'complete' || document.readyState === 'interactive') {
    reattachAllEventListeners();
}

// Add event handler for the Recovery button
document.getElementById('recover-assets-btn').addEventListener('click', () => {
    console.log('Recover Assets button clicked');
    
    if (window._lastLoadedAssets && window._lastLoadedAssets.length > 0) {
        console.log(`Recovering ${window._lastLoadedAssets.length} assets from last successful load`);
        
        // Show notification
        showNotification(`Recovering ${window._lastLoadedAssets.length} assets from saved state`, 'info');
        
        // Re-display the assets and folder structure
        displayAssets(window._lastLoadedAssets);
        generateFolderStructure(window._lastLoadedAssets);
    } else {
        console.log('No saved assets available to recover');
        showNotification('No saved assets available to recover', 'warning');
    }
});

// Event handlers for the export postfix modal
document.getElementById('cancel-postfix-btn').addEventListener('click', () => {
    document.getElementById('export-postfix-modal').classList.add('hidden');
});

// Update the final name preview when user types in the postfix input
document.getElementById('collection-postfix').addEventListener('input', (e) => {
    const postfix = e.target.value.trim();
    const activeCollection = CollectionManager.activeCollection;
    const collectionName = activeCollection ? activeCollection.name : "Collection";
    document.getElementById('final-name-preview').textContent = postfix ? `${collectionName}_${postfix}` : collectionName;
    
    // Hide any previous error when user starts typing again
    document.getElementById('postfix-error').classList.add('hidden');
});

document.getElementById('apply-postfix-btn').addEventListener('click', () => {
    const postfixInput = document.getElementById('collection-postfix');
    const postfix = postfixInput.value.trim();
    
    // Validate postfix - allow alphanumeric characters and underscores
    if (postfix && !/^[a-zA-Z0-9_]+$/.test(postfix)) {
        document.getElementById('postfix-error').classList.remove('hidden');
        return;
    }
    
    // Hide the modal
    document.getElementById('export-postfix-modal').classList.add('hidden');
    
    // Proceed with the export using the postfix
    proceedWithExport(postfix);
});
    </script>
</body>
</html>
